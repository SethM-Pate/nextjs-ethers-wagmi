import { signerToEcdsaValidator } from "@zerodev/ecdsa-validator";
import { createKernelAccount, createKernelAccountClient, createZeroDevPaymasterClient } from "@zerodev/sdk";
import { http, createPublicClient, isAddress } from "viem";
const getZeroDevBundlerRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/bundler/${projectId}`;
    if (provider) {
        rpc += `?bundlerProvider=${provider}`;
    }
    return rpc;
};
const getZeroDevPaymasterRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/paymaster/${projectId}`;
    if (provider) {
        rpc += `?paymasterProvider=${provider}`;
    }
    return rpc;
};
function isERC20(value) {
    return isAddress(value);
}
export async function createEcdsaKernelAccountClient({ chain, projectId, signer, provider, index, paymaster = "SPONSOR" }) {
    const publicClient = createPublicClient({
        transport: http(getZeroDevBundlerRPC(projectId, provider))
    });
    const ecdsaValidator = await signerToEcdsaValidator(publicClient, {
        signer
    });
    const account = await createKernelAccount(publicClient, {
        plugins: {
            sudo: ecdsaValidator
        },
        index
    });
    let sponsorUserOperation = undefined;
    if (paymaster !== undefined) {
        const zerodevPaymaster = createZeroDevPaymasterClient({
            chain: chain,
            transport: http(getZeroDevPaymasterRPC(projectId, provider))
        });
        if (isERC20(paymaster)) {
            sponsorUserOperation = async ({ userOperation }) => {
                return zerodevPaymaster.sponsorUserOperation({
                    userOperation,
                    gasToken: paymaster
                });
            };
        }
        else if (paymaster === "SPONSOR") {
            sponsorUserOperation = async ({ userOperation }) => {
                return zerodevPaymaster.sponsorUserOperation({
                    userOperation
                });
            };
        }
        else if (paymaster !== "NONE") {
            throw new Error("Invalid paymaster type");
        }
    }
    const kernelClient = createKernelAccountClient({
        account,
        chain,
        transport: http(getZeroDevBundlerRPC(projectId, provider)),
        sponsorUserOperation
    });
    return kernelClient;
}
//# sourceMappingURL=index.js.map