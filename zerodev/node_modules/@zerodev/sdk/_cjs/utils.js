"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixSignedData = exports.getERC20PaymasterApproveCall = exports.getKernelVersion = void 0;
const viem_1 = require("viem");
const index_js_1 = require("./accounts/index.js");
const constants_js_1 = require("./constants.js");
const getKernelVersion = (kernelImpl) => {
    if (!kernelImpl || kernelImpl === viem_1.zeroAddress)
        return constants_js_1.LATEST_KERNEL_VERSION;
    for (const [addr, ver] of Object.entries(constants_js_1.KernelImplToVersionMap)) {
        if (addr.toLowerCase() === kernelImpl.toLowerCase())
            return ver;
    }
    return "0.2.1";
};
exports.getKernelVersion = getKernelVersion;
const getERC20PaymasterApproveCall = async (client, { gasToken, approveAmount }) => {
    const response = await client.request({
        method: "zd_pm_accounts",
        params: [
            {
                chainId: client.chain?.id,
                entryPointAddress: index_js_1.KERNEL_ADDRESSES.ENTRYPOINT_V0_6
            }
        ]
    });
    return {
        to: gasToken,
        data: (0, viem_1.encodeFunctionData)({
            abi: viem_1.erc20Abi,
            functionName: "approve",
            args: [response[0], approveAmount]
        }),
        value: 0n
    };
};
exports.getERC20PaymasterApproveCall = getERC20PaymasterApproveCall;
const fixSignedData = (sig) => {
    let signature = sig;
    if (!(0, viem_1.isHex)(signature)) {
        signature = `0x${signature}`;
        if (!(0, viem_1.isHex)(signature)) {
            throw new Error(`Invalid signed data ${sig}`);
        }
    }
    let { r, s, v } = (0, viem_1.hexToSignature)(signature);
    if (v === 0n || v === 1n)
        v += 27n;
    const joined = (0, viem_1.signatureToHex)({ r, s, v });
    return joined;
};
exports.fixSignedData = fixSignedData;
//# sourceMappingURL=utils.js.map