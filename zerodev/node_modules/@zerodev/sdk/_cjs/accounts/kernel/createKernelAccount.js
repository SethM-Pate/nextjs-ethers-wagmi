"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createKernelAccount = exports.KERNEL_ADDRESSES = exports.EIP1271ABI = void 0;
const permissionless_1 = require("permissionless");
const accounts_1 = require("permissionless/accounts");
const viem_1 = require("viem");
const accounts_2 = require("viem/accounts");
const actions_1 = require("viem/actions");
const constants_js_1 = require("../../constants.js");
const utils_js_1 = require("../../utils.js");
const _6492_js_1 = require("../utils/6492.js");
const toKernelPluginManager_js_1 = require("../utils/toKernelPluginManager.js");
const KernelAccountAbi_js_1 = require("./abi/KernelAccountAbi.js");
const createAccountAbi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_implementation",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes"
            },
            {
                internalType: "uint256",
                name: "_index",
                type: "uint256"
            }
        ],
        name: "createAccount",
        outputs: [
            {
                internalType: "address",
                name: "proxy",
                type: "address"
            }
        ],
        stateMutability: "payable",
        type: "function"
    }
];
const createCallAddress = "0x9b35Af71d77eaf8d7e40252370304687390A1A52";
const createCallAbi = (0, viem_1.parseAbi)([
    "function performCreate(uint256 value, bytes memory deploymentData) public returns (address newContract)",
    "function performCreate2(uint256 value, bytes memory deploymentData, bytes32 salt) public returns (address newContract)"
]);
exports.EIP1271ABI = [
    {
        type: "function",
        name: "eip712Domain",
        inputs: [],
        outputs: [
            { name: "fields", type: "bytes1", internalType: "bytes1" },
            { name: "name", type: "string", internalType: "string" },
            { name: "version", type: "string", internalType: "string" },
            { name: "chainId", type: "uint256", internalType: "uint256" },
            {
                name: "verifyingContract",
                type: "address",
                internalType: "address"
            },
            { name: "salt", type: "bytes32", internalType: "bytes32" },
            { name: "extensions", type: "uint256[]", internalType: "uint256[]" }
        ],
        stateMutability: "view"
    },
    {
        type: "function",
        name: "isValidSignature",
        inputs: [
            { name: "data", type: "bytes32", internalType: "bytes32" },
            { name: "signature", type: "bytes", internalType: "bytes" }
        ],
        outputs: [
            { name: "magicValue", type: "bytes4", internalType: "bytes4" }
        ],
        stateMutability: "view"
    }
];
exports.KERNEL_ADDRESSES = {
    ACCOUNT_LOGIC: "0xd3082872F8B06073A021b4602e022d5A070d7cfC",
    FACTORY_ADDRESS: "0x5de4839a76cf55d0c90e2061ef4386d962E15ae3",
    ENTRYPOINT_V0_6: "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"
};
const getAccountInitCode = async ({ index, factoryAddress, accountLogicAddress, validatorAddress, enableData }) => {
    const initialisationData = (0, viem_1.encodeFunctionData)({
        abi: KernelAccountAbi_js_1.KernelInitAbi,
        functionName: "initialize",
        args: [validatorAddress, enableData]
    });
    return (0, viem_1.concatHex)([
        factoryAddress,
        (0, viem_1.encodeFunctionData)({
            abi: createAccountAbi,
            functionName: "createAccount",
            args: [accountLogicAddress, initialisationData, index]
        })
    ]);
};
const getAccountAddress = async ({ client, entryPoint, initCodeProvider }) => {
    const initCode = await initCodeProvider();
    return (0, permissionless_1.getSenderAddress)(client, {
        initCode,
        entryPoint
    });
};
const parseFactoryAddressAndCallDataFromAccountInitCode = (initCode) => {
    const factoryAddress = `0x${initCode.substring(2, 42)}`;
    const factoryCalldata = `0x${initCode.substring(42)}`;
    return [factoryAddress, factoryCalldata];
};
async function createKernelAccount(client, { plugins, entryPoint = exports.KERNEL_ADDRESSES.ENTRYPOINT_V0_6, index = 0n, factoryAddress = exports.KERNEL_ADDRESSES.FACTORY_ADDRESS, accountLogicAddress = exports.KERNEL_ADDRESSES.ACCOUNT_LOGIC, deployedAccountAddress }) {
    const kernelPluginManager = (0, toKernelPluginManager_js_1.isKernelPluginManager)(plugins)
        ? plugins
        : await (0, toKernelPluginManager_js_1.toKernelPluginManager)(client, {
            sudo: plugins.sudo,
            regular: plugins.regular,
            executorData: plugins.executorData,
            pluginEnableSignature: plugins.pluginEnableSignature
        });
    const generateInitCode = async () => {
        const validatorInitData = await kernelPluginManager.getValidatorInitData();
        return getAccountInitCode({
            index,
            factoryAddress,
            accountLogicAddress,
            validatorAddress: validatorInitData.validatorAddress,
            enableData: validatorInitData.enableData
        });
    };
    const accountAddress = deployedAccountAddress ??
        (await getAccountAddress({
            client,
            entryPoint,
            initCodeProvider: generateInitCode
        }));
    if (!accountAddress)
        throw new Error("Account address not found");
    const signHashedMessage = async (messageHash) => {
        let kernelImplAddr;
        try {
            const strgAddr = await (0, permissionless_1.getAction)(client, actions_1.getStorageAt)({
                address: accountAddress,
                slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
            });
            if (strgAddr)
                kernelImplAddr = `0x${strgAddr.slice(26)}`;
        }
        catch (error) { }
        const kernelVersion = (0, utils_js_1.getKernelVersion)(kernelImplAddr);
        if (kernelVersion !== "0.2.3" && kernelVersion !== "0.2.4") {
            return kernelPluginManager.signMessage({
                message: {
                    raw: messageHash
                }
            });
        }
        const domain = await client.request({
            method: "eth_call",
            params: [
                {
                    to: accountAddress,
                    data: (0, viem_1.encodeFunctionData)({
                        abi: exports.EIP1271ABI,
                        functionName: "eip712Domain"
                    })
                },
                "latest"
            ]
        });
        let name;
        let version;
        let chainId;
        if (domain !== "0x") {
            const decoded = (0, viem_1.decodeFunctionResult)({
                abi: [...exports.EIP1271ABI],
                functionName: "eip712Domain",
                data: domain
            });
            name = decoded[1];
            version = decoded[2];
            chainId = decoded[3];
        }
        else {
            name = constants_js_1.KERNEL_NAME;
            version = kernelVersion;
            chainId = client.chain
                ? BigInt(client.chain.id)
                : BigInt(await client.extend(viem_1.publicActions).getChainId());
        }
        const encoded = (0, viem_1.encodeAbiParameters)([
            { type: "bytes32" },
            { type: "bytes32" },
            { type: "bytes32" },
            { type: "uint256" },
            { type: "address" }
        ], [
            (0, viem_1.keccak256)((0, viem_1.stringToHex)("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")),
            (0, viem_1.keccak256)((0, viem_1.stringToHex)(name)),
            (0, viem_1.keccak256)((0, viem_1.stringToHex)(version)),
            BigInt(chainId),
            accountAddress
        ]);
        const domainSeparator = (0, viem_1.keccak256)(encoded);
        const digest = (0, viem_1.keccak256)((0, viem_1.concatHex)(["0x1901", domainSeparator, messageHash]));
        return kernelPluginManager.signMessage({
            message: {
                raw: digest
            }
        });
    };
    const account = (0, accounts_2.toAccount)({
        address: accountAddress,
        async signMessage({ message }) {
            const messageHash = (0, viem_1.hashMessage)(message);
            const [isDeployed, signature] = await Promise.all([
                isAccountDeployed(),
                signHashedMessage(messageHash)
            ]);
            return create6492Signature(isDeployed, signature);
        },
        async signTransaction(_, __) {
            throw new accounts_1.SignTransactionNotSupportedBySmartAccount();
        },
        async signTypedData(typedData) {
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({
                    domain: typedData.domain
                }),
                ...typedData.types
            };
            (0, viem_1.validateTypedData)({
                domain: typedData.domain,
                message: typedData.message,
                primaryType: typedData.primaryType,
                types: types
            });
            const typedHash = (0, viem_1.hashTypedData)(typedData);
            const [isDeployed, signature] = await Promise.all([
                isAccountDeployed(),
                signHashedMessage(typedHash)
            ]);
            return create6492Signature(isDeployed, signature);
        }
    });
    const isAccountDeployed = async () => {
        const contractCode = await (0, actions_1.getBytecode)(client, {
            address: accountAddress
        });
        return (contractCode?.length ?? 0) > 2;
    };
    const create6492Signature = async (isDeployed, signature) => {
        if (isDeployed) {
            return signature;
        }
        const [factoryAddress, factoryCalldata] = parseFactoryAddressAndCallDataFromAccountInitCode(await generateInitCode());
        return (0, _6492_js_1.wrapSignatureWith6492)({
            factoryAddress,
            factoryCalldata,
            signature
        });
    };
    return {
        ...account,
        client: client,
        publicKey: accountAddress,
        entryPoint: entryPoint,
        source: "kernelSmartAccount",
        kernelPluginManager,
        generateInitCode,
        async getNonce() {
            const key = await kernelPluginManager.getNonceKey();
            return (0, permissionless_1.getAccountNonce)(client, {
                sender: accountAddress,
                entryPoint: entryPoint,
                key
            });
        },
        async signUserOperation(userOperation) {
            return kernelPluginManager.signUserOperation(userOperation);
        },
        async getInitCode() {
            if (await isAccountDeployed()) {
                return "0x";
            }
            else {
                return generateInitCode();
            }
        },
        async encodeDeployCallData(_tx) {
            return (0, viem_1.encodeFunctionData)({
                abi: KernelAccountAbi_js_1.KernelExecuteAbi,
                functionName: "executeDelegateCall",
                args: [
                    createCallAddress,
                    (0, viem_1.encodeFunctionData)({
                        abi: createCallAbi,
                        functionName: "performCreate",
                        args: [
                            0n,
                            (0, viem_1.encodeDeployData)({
                                abi: _tx.abi,
                                bytecode: _tx.bytecode,
                                args: _tx.args
                            })
                        ]
                    })
                ]
            });
        },
        async encodeCallData(_tx) {
            const tx = _tx;
            if (Array.isArray(tx)) {
                return (0, viem_1.encodeFunctionData)({
                    abi: KernelAccountAbi_js_1.KernelExecuteAbi,
                    functionName: "executeBatch",
                    args: [
                        tx.map((txn) => {
                            if (txn.callType === "delegatecall") {
                                throw new Error("Cannot batch delegatecall");
                            }
                            return {
                                to: txn.to,
                                value: txn.value,
                                data: txn.data
                            };
                        })
                    ]
                });
            }
            if (!tx.callType || tx.callType === "call") {
                if (tx.to.toLowerCase() === accountAddress.toLowerCase()) {
                    return tx.data;
                }
                return (0, viem_1.encodeFunctionData)({
                    abi: KernelAccountAbi_js_1.KernelExecuteAbi,
                    functionName: "execute",
                    args: [tx.to, tx.value, tx.data, 0]
                });
            }
            if (tx.callType === "delegatecall") {
                return (0, viem_1.encodeFunctionData)({
                    abi: KernelAccountAbi_js_1.KernelExecuteAbi,
                    functionName: "executeDelegateCall",
                    args: [tx.to, tx.data]
                });
            }
            throw new Error("Invalid call type");
        },
        async getDummySignature(userOperation) {
            return kernelPluginManager.getDummySignature(userOperation);
        }
    };
}
exports.createKernelAccount = createKernelAccount;
//# sourceMappingURL=createKernelAccount.js.map