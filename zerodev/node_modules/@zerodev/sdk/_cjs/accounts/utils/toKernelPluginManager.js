"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toKernelPluginManager = exports.isKernelPluginManager = void 0;
const permissionless_1 = require("permissionless");
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const constants_js_1 = require("../../constants.js");
const kernel_js_1 = require("../../types/kernel.js");
const utils_js_1 = require("../../utils.js");
function isKernelPluginManager(plugin) {
    return plugin.getPluginEnableSignature !== undefined;
}
exports.isKernelPluginManager = isKernelPluginManager;
async function toKernelPluginManager(client, { sudo, regular, pluginEnableSignature, validatorInitData, executorData = {
    executor: viem_1.zeroAddress,
    selector: (0, viem_1.toFunctionSelector)("execute(address, uint256, bytes, uint8)")
}, validAfter = 0, validUntil = 0 }) {
    const chainId = await (0, actions_1.getChainId)(client);
    const getValidatorSignature = async (accountAddress, selector) => {
        if (regular) {
            if (await regular.isEnabled(accountAddress, selector)) {
                return kernel_js_1.ValidatorMode.plugin;
            }
            const enableSignature = await getPluginEnableSignature(accountAddress);
            const enableData = await regular.getEnableData(accountAddress);
            const enableDataLength = enableData.length / 2 - 1;
            if (!enableSignature) {
                throw new Error("Enable signature not set");
            }
            return (0, viem_1.concat)([
                kernel_js_1.ValidatorMode.enable,
                (0, viem_1.pad)((0, viem_1.toHex)(validUntil), { size: 6 }),
                (0, viem_1.pad)((0, viem_1.toHex)(validAfter), { size: 6 }),
                (0, viem_1.pad)(regular.address, { size: 20 }),
                (0, viem_1.pad)(executorData.executor, { size: 20 }),
                (0, viem_1.pad)((0, viem_1.toHex)(enableDataLength), { size: 32 }),
                enableData,
                (0, viem_1.pad)((0, viem_1.toHex)(enableSignature.length / 2 - 1), { size: 32 }),
                enableSignature
            ]);
        }
        else if (sudo) {
            return kernel_js_1.ValidatorMode.sudo;
        }
        else {
            throw new Error("One of `sudo` or `regular` validator must be set");
        }
    };
    const getPluginEnableSignature = async (accountAddress) => {
        if (pluginEnableSignature)
            return pluginEnableSignature;
        if (!sudo)
            throw new Error("sudo validator not set -- need it to enable the validator");
        if (!regular)
            throw new Error("regular validator not set");
        let kernelImplAddr;
        try {
            const strgAddr = await (0, permissionless_1.getAction)(client, actions_1.getStorageAt)({
                address: accountAddress,
                slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
            });
            if (strgAddr)
                kernelImplAddr = `0x${strgAddr.slice(26)}`;
        }
        catch (error) { }
        const ownerSig = await sudo.signTypedData({
            domain: {
                name: "Kernel",
                version: kernelImplAddr
                    ? (0, utils_js_1.getKernelVersion)(kernelImplAddr)
                    : constants_js_1.LATEST_KERNEL_VERSION,
                chainId,
                verifyingContract: accountAddress
            },
            types: {
                ValidatorApproved: [
                    { name: "sig", type: "bytes4" },
                    { name: "validatorData", type: "uint256" },
                    { name: "executor", type: "address" },
                    { name: "enableData", type: "bytes" }
                ]
            },
            message: {
                sig: executorData.selector,
                validatorData: (0, viem_1.hexToBigInt)((0, viem_1.concatHex)([
                    (0, viem_1.pad)((0, viem_1.toHex)(validUntil ?? 0), {
                        size: 6
                    }),
                    (0, viem_1.pad)((0, viem_1.toHex)(validAfter ?? 0), {
                        size: 6
                    }),
                    regular.address
                ]), { size: 32 }),
                executor: executorData.executor,
                enableData: await regular.getEnableData(accountAddress)
            },
            primaryType: "ValidatorApproved"
        });
        pluginEnableSignature = ownerSig;
        return ownerSig;
    };
    const activeValidator = regular || sudo;
    if (!activeValidator) {
        throw new Error("One of `sudo` or `regular` validator must be set");
    }
    return {
        ...activeValidator,
        signUserOperation: async (userOperation) => {
            return (0, viem_1.concatHex)([
                await getValidatorSignature(userOperation.sender, userOperation.callData.toString().slice(0, 10)),
                await activeValidator.signUserOperation(userOperation)
            ]);
        },
        getExecutorData: () => executorData,
        getValidityData: () => ({
            validAfter,
            validUntil
        }),
        getDummySignature: async (userOperation) => {
            return (0, viem_1.concatHex)([
                await getValidatorSignature(userOperation.sender, userOperation.callData.toString().slice(0, 10)),
                await activeValidator.getDummySignature(userOperation)
            ]);
        },
        getPluginEnableSignature,
        getValidatorInitData: async () => {
            if (validatorInitData)
                return validatorInitData;
            return {
                validatorAddress: sudo?.address ?? activeValidator.address,
                enableData: (await sudo?.getEnableData()) ??
                    (await activeValidator.getEnableData())
            };
        }
    };
}
exports.toKernelPluginManager = toKernelPluginManager;
//# sourceMappingURL=toKernelPluginManager.js.map