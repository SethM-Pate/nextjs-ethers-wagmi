{"version":3,"file":"simple.js","sourceRoot":"","sources":["../../../src/account/simple.ts"],"names":[],"mappings":";;;AACA,+BAQc;AACd,qEAA+D;AAC/D,mFAA6E;AAE7E,uCAGmB;AAiBnB,MAAa,0BAEX,SAAQ,kCAAoC;IAK5C,YAAY,MAAgC;QAC1C,KAAK,CAAC,MAAM,CAAC,CAAC;QALN;;;;;WAA+B;QAC/B;;;;;WAAwB;QACxB;;;;;WAAc;QAKtB,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,IAAI,EAAE,CAAC;QAChC,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;QAC1B,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;IAC9C,CAAC;IAED,iBAAiB;QACf,OAAO,sIAAsI,CAAC;IAChJ,CAAC;IAED,KAAK,CAAC,aAAa,CACjB,MAAW,EACX,KAAa,EACb,IAAS;QAET,OAAO,IAAA,yBAAkB,EAAC;YACxB,GAAG,EAAE,sCAAgB;YACrB,YAAY,EAAE,SAAS;YACvB,IAAI,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC;SAC5B,CAAC,CAAC;IACL,CAAC;IAEQ,KAAK,CAAC,kBAAkB,CAC/B,IAAgC;QAEhC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,CAClC,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;YACd,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC3B,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAEzB,OAAO,KAAK,CAAC;QACf,CAAC,EACD,CAAC,EAAE,EAAE,EAAE,CAAuB,CAC/B,CAAC;QAEF,OAAO,IAAA,yBAAkB,EAAC;YACxB,GAAG,EAAE,sCAAgB;YACrB,YAAY,EAAE,cAAc;YAC5B,IAAI,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC;SACvB,CAAC,CAAC;IACL,CAAC;IAED,WAAW,CAAC,GAAwB;QAClC,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YACnD,GAAG,GAAG,IAAA,iBAAU,EAAC,GAAU,CAAC,CAAC;SAC9B;aAAM,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YAClC,GAAG,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;SACrC;QAED,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IACrC,CAAC;IAES,KAAK,CAAC,kBAAkB;QAChC,OAAO,IAAA,gBAAS,EAAC;YACf,IAAI,CAAC,cAAc;YACnB,IAAA,yBAAkB,EAAC;gBACjB,GAAG,EAAE,oDAAuB;gBAC5B,YAAY,EAAE,eAAe;gBAC7B,IAAI,EAAE,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC;aAClD,CAAC;SACH,CAAC,CAAC;IACL,CAAC;CACF;AAvED,gEAuEC","sourcesContent":["import type { Address } from \"abitype\";\nimport {\n  concatHex,\n  encodeFunctionData,\n  hexToBytes,\n  type FallbackTransport,\n  type Hash,\n  type Hex,\n  type Transport,\n} from \"viem\";\nimport { SimpleAccountAbi } from \"../abis/SimpleAccountAbi.js\";\nimport { SimpleAccountFactoryAbi } from \"../abis/SimpleAccountFactoryAbi.js\";\nimport type { BatchUserOperationCallData } from \"../types.js\";\nimport {\n  BaseSmartContractAccount,\n  type BaseSmartAccountParams,\n} from \"./base.js\";\nimport type { SignTypedDataParams } from \"./types.js\";\n\nexport interface SimpleSmartAccountOwner {\n  signMessage: (msg: Uint8Array) => Promise<Hash>;\n  getAddress: () => Promise<Address>;\n  signTypedData: (params: SignTypedDataParams) => Promise<Hash>;\n}\n\nexport interface SimpleSmartAccountParams<\n  TTransport extends Transport | FallbackTransport = Transport\n> extends BaseSmartAccountParams<TTransport> {\n  owner: SimpleSmartAccountOwner;\n  factoryAddress: Address;\n  index?: bigint;\n}\n\nexport class SimpleSmartContractAccount<\n  TTransport extends Transport | FallbackTransport = Transport\n> extends BaseSmartContractAccount<TTransport> {\n  protected owner: SimpleSmartAccountOwner;\n  protected factoryAddress: Address;\n  protected index: bigint;\n\n  constructor(params: SimpleSmartAccountParams) {\n    super(params);\n\n    this.index = params.index ?? 0n;\n    this.owner = params.owner;\n    this.factoryAddress = params.factoryAddress;\n  }\n\n  getDummySignature(): `0x${string}` {\n    return \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n  }\n\n  async encodeExecute(\n    target: Hex,\n    value: bigint,\n    data: Hex\n  ): Promise<`0x${string}`> {\n    return encodeFunctionData({\n      abi: SimpleAccountAbi,\n      functionName: \"execute\",\n      args: [target, value, data],\n    });\n  }\n\n  override async encodeBatchExecute(\n    _txs: BatchUserOperationCallData\n  ): Promise<`0x${string}`> {\n    const [targets, datas] = _txs.reduce(\n      (accum, curr) => {\n        accum[0].push(curr.target);\n        accum[1].push(curr.data);\n\n        return accum;\n      },\n      [[], []] as [Address[], Hex[]]\n    );\n\n    return encodeFunctionData({\n      abi: SimpleAccountAbi,\n      functionName: \"executeBatch\",\n      args: [targets, datas],\n    });\n  }\n\n  signMessage(msg: Uint8Array | string): Promise<`0x${string}`> {\n    if (typeof msg === \"string\" && msg.startsWith(\"0x\")) {\n      msg = hexToBytes(msg as Hex);\n    } else if (typeof msg === \"string\") {\n      msg = new TextEncoder().encode(msg);\n    }\n\n    return this.owner.signMessage(msg);\n  }\n\n  protected async getAccountInitCode(): Promise<`0x${string}`> {\n    return concatHex([\n      this.factoryAddress,\n      encodeFunctionData({\n        abi: SimpleAccountFactoryAbi,\n        functionName: \"createAccount\",\n        args: [await this.owner.getAddress(), this.index],\n      }),\n    ]);\n  }\n}\n"]}