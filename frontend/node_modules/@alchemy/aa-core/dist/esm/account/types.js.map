{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/account/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Address } from \"abitype\";\nimport type { Hash, Hex } from \"viem\";\nimport type { SignTypedDataParameters } from \"viem/accounts\";\nimport type { BatchUserOperationCallData } from \"../types\";\n\nexport type SignTypedDataParams = Omit<SignTypedDataParameters, \"privateKey\">;\n\nexport interface ISmartContractAccount {\n  /**\n   * @returns the init code for the account\n   */\n  getInitCode(): Promise<Hex>;\n\n  /**\n   * This is useful for estimating gas costs. It should return a signature that doesn't cause the account to revert\n   * when validation is run during estimation.\n   *\n   * @returns a dummy signature that doesn't cause the account to revert during estimation\n   */\n  getDummySignature(): Hex;\n\n  /**\n   * Encodes a call to the account's execute function.\n   *\n   * @param target - the address receiving the call data\n   * @param value - optionally the amount of native token to send\n   * @param data - the call data or \"0x\" if empty\n   */\n  encodeExecute(target: string, value: bigint, data: string): Promise<Hex>;\n\n  /**\n   * Encodes a batch of transactions to the account's batch execute function.\n   * NOTE: not all accounts support batching.\n   * @param txs - An Array of objects containing the target, value, and data for each transaction\n   * @returns the encoded callData for a UserOperation\n   */\n  encodeBatchExecute(txs: BatchUserOperationCallData): Promise<Hex>;\n\n  /**\n   * @returns the nonce of the account\n   */\n  getNonce(): Promise<bigint>;\n\n  /**\n   * Returns a signed and prefixed message.\n   *\n   * @param msg - the message to sign\n   * @returns the signature of the message\n   */\n  signMessage(msg: string | Uint8Array | Hex): Promise<Hex>;\n\n  /**\n   * Signs a typed data object as per ERC-712\n   *\n   * @param params - {@link SignTypedDataParams}\n   * @returns the signed hash for the message passed\n   */\n  signTypedData(params: SignTypedDataParams): Promise<Hash>;\n\n  /**\n   * If the account is not deployed, it will sign the message and then wrap it in 6492 format\n   *\n   * @param msg - the message to sign\n   * @returns ths signature wrapped in 6492 format\n   */\n  signMessageWith6492(msg: string | Uint8Array | Hex): Promise<Hex>;\n\n  /**\n   * If the account is not deployed, it will sign the typed data blob and then wrap it in 6492 format\n   *\n   * @param params - {@link SignTypedDataParams}\n   * @returns the signed hash for the params passed in wrapped in 6492 format\n   */\n  signTypedDataWith6492(params: SignTypedDataParams): Promise<Hash>;\n\n  /**\n   * @returns the address of the account\n   */\n  getAddress(): Promise<Address>;\n}\n"]}