{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/provider/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Address } from \"abitype\";\nimport type { Hash, Hex, RpcTransactionRequest, Transport } from \"viem\";\nimport type { SignTypedDataParameters } from \"viem/accounts\";\nimport type { BaseSmartContractAccount } from \"../account/base.js\";\nimport type { SignTypedDataParams } from \"../account/types.js\";\nimport type {\n  PublicErc4337Client,\n  SupportedTransports,\n} from \"../client/types.js\";\nimport type {\n  BatchUserOperationCallData,\n  UserOperationCallData,\n  UserOperationReceipt,\n  UserOperationRequest,\n  UserOperationResponse,\n  UserOperationStruct,\n} from \"../types.js\";\n\ntype WithRequired<T, K extends keyof T> = Required<Pick<T, K>>;\ntype WithOptional<T, K extends keyof T> = Pick<Partial<T>, K>;\n\nexport type ConnectorData = {\n  chainId?: Hex;\n};\n\nexport interface ProviderEvents {\n  chainChanged(chainId: Hex): void;\n  accountsChanged(accounts: Address[]): void;\n  connect(data: ConnectorData): void;\n  message({ type, data }: { type: string; data?: unknown }): void;\n  disconnect(): void;\n  error(error: Error): void;\n}\n\nexport type SendUserOperationResult = {\n  hash: string;\n  request: UserOperationRequest;\n};\n\nexport type AccountMiddlewareFn = (\n  struct: UserOperationStruct\n) => Promise<UserOperationStruct>;\n\nexport type AccountMiddlewareOverrideFn<\n  Req extends keyof UserOperationStruct = never,\n  Opt extends keyof UserOperationStruct = never\n> = (\n  struct: UserOperationStruct\n) => Promise<\n  WithRequired<UserOperationStruct, Req> &\n    WithOptional<UserOperationStruct, Opt>\n>;\n\nexport type PaymasterAndDataMiddleware = AccountMiddlewareOverrideFn<\n  \"paymasterAndData\",\n  | \"callGasLimit\"\n  | \"preVerificationGas\"\n  | \"verificationGasLimit\"\n  | \"maxFeePerGas\"\n  | \"maxPriorityFeePerGas\"\n>;\n\nexport type GasEstimatorMiddleware = AccountMiddlewareOverrideFn<\n  \"callGasLimit\" | \"preVerificationGas\" | \"verificationGasLimit\"\n>;\nexport type FeeDataMiddleware = AccountMiddlewareOverrideFn<\n  \"maxFeePerGas\" | \"maxPriorityFeePerGas\"\n>;\n\n// TODO: this also will need to implement EventEmitteer\nexport interface ISmartAccountProvider<\n  TTransport extends SupportedTransports = Transport\n> {\n  readonly rpcClient: PublicErc4337Client<TTransport>;\n  readonly dummyPaymasterDataMiddleware: AccountMiddlewareFn;\n  readonly paymasterDataMiddleware: AccountMiddlewareFn;\n  readonly gasEstimator: AccountMiddlewareFn;\n  readonly feeDataGetter: AccountMiddlewareFn;\n  readonly customMiddleware?: AccountMiddlewareFn;\n\n  readonly account?: BaseSmartContractAccount;\n\n  /**\n   * Sends a user operation using the connected account.\n   * Before executing, sendUserOperation will run the user operation through the middleware pipeline.\n   * The order of the middlewares is:\n   * 1. dummyPaymasterDataMiddleware -- populates a dummy paymaster data to use in estimation (default: \"0x\")\n   * 2. gasEstimator -- calls eth_estimateUserOperationGas\n   * 3. feeDataGetter -- sets maxfeePerGas and maxPriorityFeePerGas\n   * 4. paymasterMiddleware -- used to set paymasterAndData. (default: \"0x\")\n   *\n   * @param data - either {@link UserOperationCallData} or {@link BatchUserOperationCallData}\n   * @returns - {@link SendUserOperationResult} containing the hash and request\n   */\n  sendUserOperation: (\n    data: UserOperationCallData | BatchUserOperationCallData\n  ) => Promise<SendUserOperationResult>;\n\n  /**\n   * This will wait for the user operation to be included in a transaction that's been mined.\n   * The default retry and wait logic is configured on the Provider itself\n   *\n   * @param hash the user operation hash you want to wait for\n   * @returns the tx hash that included this user operation\n   */\n  waitForUserOperationTransaction: (hash: Hash) => Promise<Hash>;\n\n  /**\n   * calls `eth_getUserOperationByHash` and returns the {@link UserOperationResponse}\n   *\n   * @param hash - the hash of the UserOperation to get the receipt for\n   * @returns - {@link UserOperationResponse}\n   */\n  getUserOperationByHash: (hash: Hash) => Promise<UserOperationResponse>;\n\n  /**\n   * calls `eth_getUserOperationReceipt` and returns the {@link UserOperationReceipt}\n   *\n   * @param hash - the hash of the UserOperation to get the receipt for\n   * @returns - {@link UserOperationResponse}\n   */\n  getUserOperationReceipt: (hash: Hash) => Promise<UserOperationReceipt>;\n\n  /**\n   * This takes an ethereum transaction and converts it into a UserOperation, sends the UserOperation, and waits\n   * on the receipt of that UserOperation (ie. has it been mined). If you don't want to wait for the UserOperation\n   * to mine, it's recommended to user {@link sendUserOperation} instead.\n   *\n   * @param request - a {@link RpcTransactionRequest} object representing a traditional ethereum transaction\n   * @returns the transaction hash\n   */\n  sendTransaction: (request: RpcTransactionRequest) => Promise<Hash>;\n\n  /**\n   * This takes a set of  ethereum transactions and converts them into one UserOperation, sends the UserOperation, and waits\n   * on the receipt of that UserOperation (ie. has it been mined). If you don't want to wait for the UserOperation\n   * to mine, it's recommended to user {@link sendUserOperation} instead.\n   *\n   * NOTE: the account you're sending the transactions to MUST support batch transactions.\n   *\n   * @param request - a {@link RpcTransactionRequest} Array representing a traditional ethereum transaction\n   * @returns the transaction hash\n   */\n  sendTransactions: (request: RpcTransactionRequest[]) => Promise<Hash>;\n\n  /**\n   * EIP-1193 compliant request method\n   *\n   * @param args - object containing the method and params to execute\n   * @returns the result of the method call\n   */\n  request(args: { method: string; params?: any[] }): Promise<any>;\n\n  /**\n   * This method returns an ERC-191 compliant signed message\n   *\n   * @param msg - message to be signed\n   * @returns the signed hash for the message passed\n   */\n  signMessage: (msg: string | Uint8Array) => Promise<Hash>;\n\n  /**\n   * This method is used to sign typed data as per ERC-712\n   *\n   * @param params - {@link SignTypedDataParameters}\n   * @returns the signed hash for the message passed\n   */\n  signTypedData: (params: SignTypedDataParameters) => Promise<Hash>;\n\n  /**\n   * If the account is not deployed, it will sign the message and then wrap it in 6492 format\n   *\n   * @param msg - the message to sign\n   * @returns ths signature wrapped in 6492 format\n   */\n  signMessageWith6492(msg: string | Uint8Array | Hex): Promise<Hex>;\n\n  /**\n   * If the account is not deployed, it will sign the typed data blob and then wrap it in 6492 format\n   *\n   * @param params - {@link SignTypedDataParameters}\n   * @returns the signed hash for the params passed in wrapped in 6492 format\n   */\n  signTypedDataWith6492(params: SignTypedDataParams): Promise<Hash>;\n\n  // TODO: potentially add methods here for something like viem's walletActions?\n  /**\n   * @returns the address of the connected account\n   */\n  getAddress: () => Promise<Address>;\n\n  // Middelware Overriders\n  /**\n   * This method allows you to override the default dummy paymaster data middleware and get paymaster\n   * and data middleware. These middleware are often used together. The dummy paymaster data is used in\n   * gas estimation before we actually have paymaster data. Because the paymaster data has an impact on\n   * the gas estimation, it's good to supply dummy paymaster data that is valid for your paymaster contract.\n   * The getPaymasterAndDataMiddleware is used to make an RPC call to the paymaster contract to get the value\n   * for paymasterAndData.\n   *\n   * @param overrides - optional functions for overriding the default paymaster middleware\n   * @returns an update instance of this, which now uses the new middleware\n   */\n  withPaymasterMiddleware: (overrides: {\n    dummyPaymasterDataMiddleware?: PaymasterAndDataMiddleware;\n    paymasterDataMiddleware?: PaymasterAndDataMiddleware;\n  }) => this;\n\n  /**\n   * Overrides the gasEstimator middleware which is used for setting the gasLimit fields on the UserOperation\n   * prior to execution.\n   *\n   * @param override - a function for overriding the default gas estimator middleware\n   * @returns\n   */\n  withGasEstimator: (override: GasEstimatorMiddleware) => this;\n\n  /**\n   * Overrides the feeDataGetter middleware which is used for setting the fee fields on the UserOperation\n   * prior to execution.\n   *\n   * @param override - a function for overriding the default feeDataGetter middleware\n   * @returns\n   */\n  withFeeDataGetter: (override: FeeDataMiddleware) => this;\n\n  /**\n   * This adds a final middleware step to the middleware stack that runs right before signature verification.\n   * This can be used if you have an RPC that does most of the functions of the other middlewares for you and\n   * you want to delegate that work to that RPC instead of chaining together multiple RPC calls via the default middlwares.\n   *\n   * @param override - the UO transform function to run\n   * @returns\n   */\n  withCustomMiddleware: (override: AccountMiddlewareFn) => this;\n\n  /**\n   * Sets the current account to the account returned by the given function. The function parameter\n   * provides the public rpc client that is used by this provider so the account can make RPC calls.\n   *\n   * @param fn - a function that given public rpc client, returns a smart contract account\n   */\n  connect(\n    fn: (provider: PublicErc4337Client<TTransport>) => BaseSmartContractAccount\n  ): this & { account: BaseSmartContractAccount };\n\n  /**\n   * Allows for disconnecting the account from the provider so you can connect the provider to another account instance\n   *\n   * @returns the provider with the account disconnected\n   */\n  disconnect(): this & { account: undefined };\n}\n"]}