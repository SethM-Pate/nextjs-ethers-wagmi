import { default as EventEmitter } from "eventemitter3";
import { fromHex, toHex, } from "viem";
import { arbitrum, arbitrumGoerli } from "viem/chains";
import { BaseSmartContractAccount } from "../account/base.js";
import { createPublicErc4337Client } from "../client/create-client.js";
import { isValidRequest, } from "../types.js";
import { asyncPipe, deepHexlify, defineReadOnly, getUserOperationHash, resolveProperties, } from "../utils.js";
export const noOpMiddleware = async (struct) => struct;
const minPriorityFeePerBidDefaults = new Map([
    [arbitrum.id, 10000000n],
    [arbitrumGoerli.id, 10000000n],
]);
export class SmartAccountProvider extends EventEmitter {
    constructor(rpcProvider, entryPointAddress, chain, account, opts) {
        super();
        Object.defineProperty(this, "entryPointAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: entryPointAddress
        });
        Object.defineProperty(this, "chain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: chain
        });
        Object.defineProperty(this, "account", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: account
        });
        Object.defineProperty(this, "txMaxRetries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "txRetryIntervalMs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "txRetryMulitplier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minPriorityFeePerBid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rpcClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (args) => {
                const { method, params } = args;
                switch (method) {
                    case "eth_sendTransaction":
                        const [tx] = params;
                        return this.sendTransaction(tx);
                    case "eth_sign":
                    case "personal_sign":
                        const [data, address] = params;
                        if (address !== (await this.getAddress())) {
                            throw new Error("cannot sign for address that is not the current account");
                        }
                        return this.signMessage(data);
                    default:
                        return this.rpcClient.request(args);
                }
            }
        });
        Object.defineProperty(this, "getAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                if (!this.account) {
                    throw new Error("account not connected!");
                }
                return this.account.getAddress();
            }
        });
        Object.defineProperty(this, "sendTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (request) => {
                if (!request.to) {
                    throw new Error("transaction is missing to address");
                }
                const overrides = {};
                if (request.maxFeePerGas) {
                    overrides.maxFeePerGas = request.maxFeePerGas;
                }
                if (request.maxPriorityFeePerGas) {
                    overrides.maxPriorityFeePerGas = request.maxPriorityFeePerGas;
                }
                const { hash } = await this.sendUserOperation({
                    target: request.to,
                    data: request.data ?? "0x",
                    value: request.value ? fromHex(request.value, "bigint") : 0n,
                }, overrides);
                return await this.waitForUserOperationTransaction(hash);
            }
        });
        Object.defineProperty(this, "signMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (msg) => {
                if (!this.account) {
                    throw new Error("account not connected!");
                }
                return this.account.signMessage(msg);
            }
        });
        Object.defineProperty(this, "signTypedData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (params) => {
                if (!this.account) {
                    throw new Error("account not connected!");
                }
                return this.account.signTypedData(params);
            }
        });
        Object.defineProperty(this, "sendTransactions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (requests) => {
                const batch = requests.map((request) => {
                    if (!request.to) {
                        throw new Error("one transaction in the batch is missing a target address");
                    }
                    return {
                        target: request.to,
                        data: request.data ?? "0x",
                        value: request.value ? fromHex(request.value, "bigint") : 0n,
                    };
                });
                const bigIntMax = (...args) => {
                    if (!args.length) {
                        return undefined;
                    }
                    return args.reduce((m, c) => (m > c ? m : c));
                };
                const maxFeePerGas = bigIntMax(...requests
                    .filter((x) => x.maxFeePerGas != null)
                    .map((x) => fromHex(x.maxFeePerGas, "bigint")));
                const maxPriorityFeePerGas = bigIntMax(...requests
                    .filter((x) => x.maxPriorityFeePerGas != null)
                    .map((x) => fromHex(x.maxPriorityFeePerGas, "bigint")));
                const overrides = {};
                if (maxFeePerGas != null) {
                    overrides.maxFeePerGas = maxFeePerGas;
                }
                if (maxPriorityFeePerGas != null) {
                    overrides.maxPriorityFeePerGas = maxPriorityFeePerGas;
                }
                const { hash } = await this.sendUserOperation(batch, overrides);
                return await this.waitForUserOperationTransaction(hash);
            }
        });
        Object.defineProperty(this, "waitForUserOperationTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (hash) => {
                for (let i = 0; i < this.txMaxRetries; i++) {
                    const txRetryIntervalWithJitterMs = this.txRetryIntervalMs * Math.pow(this.txRetryMulitplier, i) +
                        Math.random() * 100;
                    await new Promise((resolve) => setTimeout(resolve, txRetryIntervalWithJitterMs));
                    const receipt = await this.getUserOperationReceipt(hash)
                        .catch(() => null);
                    if (receipt) {
                        return this.getTransaction(receipt.receipt.transactionHash).then((x) => x.hash);
                    }
                }
                throw new Error("Failed to find transaction for User Operation");
            }
        });
        Object.defineProperty(this, "getUserOperationByHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (hash) => {
                return this.rpcClient.getUserOperationByHash(hash);
            }
        });
        Object.defineProperty(this, "getUserOperationReceipt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (hash) => {
                return this.rpcClient.getUserOperationReceipt(hash);
            }
        });
        Object.defineProperty(this, "getTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (hash) => {
                return this.rpcClient.getTransaction({ hash: hash });
            }
        });
        Object.defineProperty(this, "sendUserOperation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (data, overrides) => {
                if (!this.account) {
                    throw new Error("account not connected!");
                }
                const initCode = await this.account.getInitCode();
                const uoStruct = await asyncPipe(this.dummyPaymasterDataMiddleware, this.feeDataGetter, this.gasEstimator, this.paymasterDataMiddleware, this.customMiddleware ?? noOpMiddleware, async (struct) => ({ ...struct, ...overrides }))({
                    initCode,
                    sender: this.getAddress(),
                    nonce: this.account.getNonce(),
                    callData: Array.isArray(data)
                        ? this.account.encodeBatchExecute(data)
                        : this.account.encodeExecute(data.target, data.value ?? 0n, data.data),
                    signature: this.account.getDummySignature(),
                });
                const request = deepHexlify(await resolveProperties(uoStruct));
                if (!isValidRequest(request)) {
                    throw new Error(`Request is missing parameters. All properties on UserOperationStruct must be set. uo: ${JSON.stringify(request, null, 2)}`);
                }
                request.signature = (await this.account.signMessage(getUserOperationHash(request, this.entryPointAddress, BigInt(this.chain.id))));
                return {
                    hash: await this.rpcClient.sendUserOperation(request, this.entryPointAddress),
                    request,
                };
            }
        });
        Object.defineProperty(this, "dummyPaymasterDataMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (struct) => {
                struct.paymasterAndData = "0x";
                return struct;
            }
        });
        Object.defineProperty(this, "paymasterDataMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (struct) => {
                struct.paymasterAndData = "0x";
                return struct;
            }
        });
        Object.defineProperty(this, "gasEstimator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (struct) => {
                const request = deepHexlify(await resolveProperties(struct));
                const estimates = await this.rpcClient.estimateUserOperationGas(request, this.entryPointAddress);
                struct.callGasLimit = estimates.callGasLimit;
                struct.verificationGasLimit = estimates.verificationGasLimit;
                struct.preVerificationGas = estimates.preVerificationGas;
                return struct;
            }
        });
        Object.defineProperty(this, "feeDataGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (struct) => {
                const maxPriorityFeePerGas = await this.rpcClient.getMaxPriorityFeePerGas();
                const feeData = await this.rpcClient.getFeeData();
                if (!feeData.maxFeePerGas || !feeData.maxPriorityFeePerGas) {
                    throw new Error("feeData is missing maxFeePerGas or maxPriorityFeePerGas");
                }
                let maxPriorityFeePerGasBid = (BigInt(maxPriorityFeePerGas) * 4n) / 3n;
                if (maxPriorityFeePerGasBid < this.minPriorityFeePerBid) {
                    maxPriorityFeePerGasBid = this.minPriorityFeePerBid;
                }
                const maxFeePerGasBid = BigInt(feeData.maxFeePerGas) -
                    BigInt(feeData.maxPriorityFeePerGas) +
                    maxPriorityFeePerGasBid;
                struct.maxFeePerGas = maxFeePerGasBid;
                struct.maxPriorityFeePerGas = maxPriorityFeePerGasBid;
                return struct;
            }
        });
        Object.defineProperty(this, "customMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "withPaymasterMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (overrides) => {
                const newDummyMiddleware = overrides.dummyPaymasterDataMiddleware
                    ? this.overrideMiddlewareFunction(overrides.dummyPaymasterDataMiddleware)
                    : this.dummyPaymasterDataMiddleware;
                defineReadOnly(this, "dummyPaymasterDataMiddleware", newDummyMiddleware);
                const newPaymasterMiddleware = overrides.paymasterDataMiddleware
                    ? this.overrideMiddlewareFunction(overrides.paymasterDataMiddleware)
                    : this.paymasterDataMiddleware;
                defineReadOnly(this, "paymasterDataMiddleware", newPaymasterMiddleware);
                return this;
            }
        });
        Object.defineProperty(this, "withGasEstimator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                defineReadOnly(this, "gasEstimator", this.overrideMiddlewareFunction(override));
                return this;
            }
        });
        Object.defineProperty(this, "withFeeDataGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                defineReadOnly(this, "feeDataGetter", this.overrideMiddlewareFunction(override));
                return this;
            }
        });
        Object.defineProperty(this, "withCustomMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                defineReadOnly(this, "customMiddleware", override);
                return this;
            }
        });
        Object.defineProperty(this, "overrideMiddlewareFunction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                return async (struct) => {
                    return {
                        ...struct,
                        ...(await override(struct)),
                    };
                };
            }
        });
        this.txMaxRetries = opts?.txMaxRetries ?? 5;
        this.txRetryIntervalMs = opts?.txRetryIntervalMs ?? 2000;
        this.txRetryMulitplier = opts?.txRetryMulitplier ?? 1.5;
        this.minPriorityFeePerBid =
            opts?.minPriorityFeePerBid ??
                minPriorityFeePerBidDefaults.get(chain.id) ??
                100000000n;
        this.rpcClient =
            typeof rpcProvider === "string"
                ? createPublicErc4337Client({
                    chain,
                    rpcUrl: rpcProvider,
                })
                : rpcProvider;
    }
    signMessageWith6492(msg) {
        if (!this.account) {
            throw new Error("account not connected!");
        }
        return this.account.signMessageWith6492(msg);
    }
    signTypedDataWith6492(params) {
        if (!this.account) {
            throw new Error("account not connected!");
        }
        return this.account.signTypedDataWith6492(params);
    }
    connect(fn) {
        const account = fn(this.rpcClient);
        defineReadOnly(this, "account", account);
        this.emit("connect", {
            chainId: toHex(this.chain.id),
        });
        account
            .getAddress()
            .then((address) => this.emit("accountsChanged", [address]));
        return this;
    }
    disconnect() {
        if (this.account) {
            this.emit("disconnect");
            this.emit("accountsChanged", []);
        }
        defineReadOnly(this, "account", undefined);
        return this;
    }
    isConnected() {
        return this.account !== undefined;
    }
}
//# sourceMappingURL=base.js.map