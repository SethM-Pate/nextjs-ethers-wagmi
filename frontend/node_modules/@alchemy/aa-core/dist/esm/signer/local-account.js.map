{"version":3,"file":"local-account.js","sourceRoot":"","sources":["../../../src/signer/local-account.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAoD,MAAM,MAAM,CAAC;AAC/E,OAAO,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,MAAM,eAAe,CAAC;AAIvE,MAAM,OAAO,kBAAkB;IAI7B,YAAY,KAAQ;QADZ;;;;;WAAS;QAKR;;;;mBAAoE,CAC3E,GAAG,EACH,EAAE;gBACF,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;oBAC1C,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;wBAC5B,OAAO,EAAE,GAAG;qBACb,CAAC,CAAC;iBACJ;qBAAM;oBACL,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;wBAC5B,OAAO,EAAE;4BACP,GAAG,EAAE,GAAG;yBACT;qBACF,CAAC,CAAC;iBACJ;YACH,CAAC;WAAC;QAEO;;;;mBAAgB,CAAC,MAA2B,EAAE,EAAE;gBACvD,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;YAC1C,CAAC;WAAC;QAEO;;;;mBAA2C,KAAK,IAAI,EAAE;gBAC7D,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;YAC5B,CAAC;WAAC;QAzBA,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IA0BD,MAAM,CAAC,uBAAuB,CAAC,GAAW;QACxC,MAAM,KAAK,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC;QACrC,OAAO,IAAI,kBAAkB,CAAC,KAAK,CAAC,CAAC;IACvC,CAAC;IAED,MAAM,CAAC,yBAAyB,CAC9B,GAAQ;QAER,MAAM,KAAK,GAAG,mBAAmB,CAAC,GAAG,CAAC,CAAC;QACvC,OAAO,IAAI,kBAAkB,CAAC,KAAK,CAAC,CAAC;IACvC,CAAC;CACF","sourcesContent":["import { isHex, type HDAccount, type Hex, type PrivateKeyAccount } from \"viem\";\nimport { mnemonicToAccount, privateKeyToAccount } from \"viem/accounts\";\nimport type { SignTypedDataParams } from \"../account/types.js\";\nimport type { SmartAccountSigner } from \"./types.js\";\n\nexport class LocalAccountSigner<T extends HDAccount | PrivateKeyAccount>\n  implements SmartAccountSigner\n{\n  private owner: T;\n  constructor(owner: T) {\n    this.owner = owner;\n  }\n\n  readonly signMessage: (msg: string | Uint8Array) => Promise<`0x${string}`> = (\n    msg\n  ) => {\n    if (typeof msg === \"string\" && !isHex(msg)) {\n      return this.owner.signMessage({\n        message: msg,\n      });\n    } else {\n      return this.owner.signMessage({\n        message: {\n          raw: msg,\n        },\n      });\n    }\n  };\n\n  readonly signTypedData = (params: SignTypedDataParams) => {\n    return this.owner.signTypedData(params);\n  };\n\n  readonly getAddress: () => Promise<`0x${string}`> = async () => {\n    return this.owner.address;\n  };\n\n  static mnemonicToAccountSigner(key: string): LocalAccountSigner<HDAccount> {\n    const owner = mnemonicToAccount(key);\n    return new LocalAccountSigner(owner);\n  }\n\n  static privateKeyToAccountSigner(\n    key: Hex\n  ): LocalAccountSigner<PrivateKeyAccount> {\n    const owner = privateKeyToAccount(key);\n    return new LocalAccountSigner(owner);\n  }\n}\n"]}