"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecoveryProvider = void 0;
const base_js_1 = require("./base.js");
const recovery_validator_js_1 = require("../validator/recovery-validator.js");
const index_js_1 = require("../api/index.js");
const chains_1 = require("viem/chains");
const constants_js_1 = require("../constants.js");
const viem_1 = require("viem");
const RecoveryActionAbi_js_1 = require("../abis/RecoveryActionAbi.js");
const KernelAccountAbi_js_1 = require("../abis/KernelAccountAbi.js");
const WeightedValidatorAbi_js_1 = require("../abis/WeightedValidatorAbi.js");
const utils_js_1 = require("../utils.js");
class RecoveryProvider extends base_js_1.ValidatorProvider {
    constructor(params) {
        const chain = typeof params.opts?.providerConfig?.chain === "number"
            ? (0, utils_js_1.getChain)(params.opts.providerConfig.chain)
            : params.opts?.providerConfig?.chain ?? chains_1.polygonMumbai;
        const validator = new recovery_validator_js_1.RecoveryValidator({
            projectId: params.projectId,
            chain,
            recoveryId: params.recoveryId,
            validatorAddress: params.opts?.validatorConfig?.validatorAddress ??
                constants_js_1.RECOVERY_VALIDATOR_ADDRESS,
            ...params.opts?.validatorConfig,
        });
        super({
            ...params,
            opts: {
                ...params.opts,
                providerConfig: { ...params.opts?.providerConfig, chain },
            },
        }, validator);
        Object.defineProperty(this, "recoveryId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "enableData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "deleteRecoveryData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.sendDisableUserOperation
        });
        this.recoveryId = params.recoveryId;
        this.enableData = params.enableData;
    }
    static async init(params) {
        const chainId = await (0, index_js_1.getChainId)(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = (0, utils_js_1.getChain)(chainId);
        let accountAddress, enableData, signatures, serializedRecoveryConfig, recoveryConfig;
        if (params.recoveryId) {
            ({
                scwAddress: accountAddress,
                enableData,
                recoveryConfig: serializedRecoveryConfig,
                signatures,
            } = await (0, index_js_1.getRecoveryData)(params.recoveryId));
            recoveryConfig = RecoveryProvider.deserializeRecoveryConfig(serializedRecoveryConfig);
        }
        else if (params.opts?.accountConfig?.accountAddress &&
            (!params.opts?.validatorConfig?.guardians ||
                !Object.entries(params.opts?.validatorConfig?.guardians).length ||
                params.opts.validatorConfig.threshold === undefined)) {
            const publicClient = (0, viem_1.createPublicClient)({
                transport: (0, viem_1.http)(params.opts.providerConfig?.rpcUrl ??
                    constants_js_1.CHAIN_ID_TO_NODE[chain?.id ?? chains_1.polygonMumbai.id]),
                chain: chain ?? chains_1.polygonMumbai,
            });
            recoveryConfig = await recovery_validator_js_1.RecoveryValidator.fetchRecoveryConfigFromContract(params.opts?.accountConfig?.accountAddress, publicClient);
        }
        const instance = new RecoveryProvider({
            enableData,
            ...params,
            opts: {
                ...params.opts,
                providerConfig: {
                    chain,
                    ...params.opts?.providerConfig,
                },
                accountConfig: {
                    accountAddress,
                    ...params.opts?.accountConfig,
                },
                validatorConfig: {
                    signatures,
                    ...recoveryConfig,
                    ...params.opts?.validatorConfig,
                },
            },
        });
        return instance;
    }
    async getDefaultValidator() {
        const publicClient = this.getValidator().getPublicClient();
        const kernelAccountAddress = await this.getAddress();
        return await publicClient.readContract({
            abi: KernelAccountAbi_js_1.KernelAccountAbi,
            address: kernelAccountAddress,
            functionName: "getDefaultValidator",
        });
    }
    async encodeCalldataAndNonce(enableData) {
        const defaultValidatorAddress = await this.getDefaultValidator();
        const callData = (0, viem_1.encodeFunctionData)({
            abi: RecoveryActionAbi_js_1.RecoveryActionAbi,
            functionName: "doRecovery",
            args: [defaultValidatorAddress, enableData],
        });
        const sender = await this.getAddress();
        const nonce = await (await this.getAccount()).getNonce();
        const encodedCallDataAndNonce = (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)("address sender, bytes calldata, uint256 nonce"), [sender, callData, nonce]);
        return (0, viem_1.keccak256)(encodedCallDataAndNonce);
    }
    async enableRecovery() {
        if (!this.defaultProvider) {
            throw Error("DefaultProvider uninitilised");
        }
        const { selector } = await this.getValidator().getPluginValidatorData();
        const kernelAccountAddress = await this.defaultProvider.getAddress();
        const encodedSetExecData = await this.getAccount().encodeSetExection();
        if (await this.getValidator().isPluginEnabled(kernelAccountAddress, selector)) {
            throw Error("Plugin already enabled");
        }
        return await this.defaultProvider.sendUserOperation({
            target: kernelAccountAddress,
            data: encodedSetExecData,
        });
    }
    async renewRecovery() {
        if (!this.defaultProvider) {
            throw Error("DefaultProvider uninitilised");
        }
        const enableData = await this.getValidator().getEnableData();
        const [guardians, weights, threshold, delay] = (0, viem_1.decodeAbiParameters)((0, viem_1.parseAbiParameters)("address[] guardians, uint24[] weights, uint24 threshold, uint48 delay"), enableData);
        const encodedRenewData = await this.getValidator().encodeRenew([...guardians], [...weights], threshold, delay);
        return await this.defaultProvider.sendUserOperation({
            target: this.getValidator().validatorAddress,
            data: encodedRenewData,
        });
    }
    async initiateRecovery(enableData) {
        const serializedConfig = this.serializeRecoveryConfig();
        const recoveryId = await (0, index_js_1.postRecoveryData)(enableData, await this.getAddress(), serializedConfig);
        console.log(recoveryId);
        this.enableData = enableData;
        if (!recoveryId) {
            throw Error("Unable to generate the recoveryId");
        }
        return recoveryId;
    }
    serializeRecoveryConfig() {
        let recoveryConfig = this.getValidator().getRecoveryConfig();
        const jsonString = JSON.stringify(recoveryConfig);
        const uint8Array = new TextEncoder().encode(jsonString);
        const base64String = (0, utils_js_1.bytesToBase64)(uint8Array);
        return base64String;
    }
    static deserializeRecoveryConfig(recoveryConfig) {
        const uint8Array = (0, utils_js_1.base64ToBytes)(recoveryConfig);
        const jsonString = new TextDecoder().decode(uint8Array);
        return JSON.parse(jsonString);
    }
    async approveRecovery(enableData) {
        const fetchedEnableData = enableData ?? this.enableData;
        if (!fetchedEnableData) {
            throw Error("Unable to fetch enable data for Recovery");
        }
        const kernelAccountAddress = await this.getAddress();
        const callDataAndNonceHash = await this.encodeCalldataAndNonce(fetchedEnableData);
        const validator = this.getValidator();
        if (!validator.walletClient) {
            throw Error("WalletClient uninitialized");
        }
        const walletClient = validator.walletClient.extend(viem_1.publicActions);
        let account;
        if (walletClient.account) {
            account = walletClient.account;
        }
        else {
            [account] = await walletClient.requestAddresses();
        }
        const hash = await walletClient.sendTransaction({
            account,
            to: validator.getAddress(),
            data: validator.encodeApprove(callDataAndNonceHash, kernelAccountAddress),
        });
        return await walletClient.waitForTransactionReceipt({
            hash,
            timeout: 180000,
        });
    }
    async signRecovery(enableData) {
        try {
            if (!this.recoveryId) {
                throw Error("RecoveryId not set");
            }
            const fetchedEnableData = enableData ?? this.enableData;
            if (!fetchedEnableData) {
                throw Error("Unable to fetch enable data for Recovery");
            }
            const callDataAndNonceHash = await this.encodeCalldataAndNonce(fetchedEnableData);
            const sig = await this.getValidator().signRecoveryHash(callDataAndNonceHash);
            const { result, data } = await (0, index_js_1.setSignatures)(this.recoveryId, sig);
            if (result !== "success") {
                throw Error("Failed to save the signatures");
            }
            this.getValidator().setRecoverySignatures(data.signatures);
        }
        catch (error) {
            console.log(error);
        }
    }
    async approveRecoveryWithSig(enableData, sigs) {
        const fetchedEnableData = enableData ?? this.enableData;
        if (!fetchedEnableData) {
            throw Error("Unable to fetch enable data for Recovery");
        }
        const signatures = sigs ?? (await this.getValidator().getRecoverySignatures());
        if (!signatures) {
            throw Error("Signatures are not set");
        }
        const kernelAccountAddress = await this.getAddress();
        const callDataAndNonceHash = await this.encodeCalldataAndNonce(fetchedEnableData);
        const validator = this.getValidator();
        if (!validator.walletClient) {
            throw Error("WalletClient uninitilized");
        }
        const walletClient = validator.walletClient.extend(viem_1.publicActions);
        let account;
        if (walletClient.account) {
            account = walletClient.account;
        }
        else {
            [account] = await walletClient.requestAddresses();
        }
        const hash = await walletClient.sendTransaction({
            account,
            to: validator.getAddress(),
            data: validator.encodeApproveWithSig(callDataAndNonceHash, kernelAccountAddress, sigs),
        });
        return await walletClient.waitForTransactionReceipt({ hash });
    }
    async cancelRecovery(enableData) {
        const fetchedEnableData = enableData ?? this.enableData;
        if (!fetchedEnableData) {
            throw Error("Unable to fetch enable data for Recovery");
        }
        if (!this.defaultProvider) {
            throw Error("DefaultProvider uninitilised");
        }
        const callDataAndNonceHash = await this.encodeCalldataAndNonce(fetchedEnableData);
        const encodedVetoData = await this.getValidator().encodeVeto(callDataAndNonceHash);
        return await this.defaultProvider.sendUserOperation({
            target: this.getValidator().validatorAddress,
            data: encodedVetoData,
        });
    }
    async submitRecovery(enableData) {
        const fetchedEnableData = enableData ?? this.enableData;
        if (!fetchedEnableData) {
            throw Error("Unable to fetch enable data for Recovery");
        }
        const defaultValidatorAddress = await this.getDefaultValidator();
        const encodedRecoveryActionData = await this.getValidator().encodeRecoveryAction(fetchedEnableData, defaultValidatorAddress);
        return await this.sendUserOperation({
            target: await this.getAddress(),
            data: encodedRecoveryActionData,
        });
    }
    async getApproval(enableData) {
        const fetchedEnableData = enableData ?? this.enableData;
        if (!fetchedEnableData) {
            throw Error("Unable to fetch enable data for Recovery");
        }
        const callDataAndNonceHash = await this.encodeCalldataAndNonce(fetchedEnableData);
        const publicClient = this.getValidator().getPublicClient();
        const kernelAccountAddress = await this.getAddress();
        return await publicClient.readContract({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            address: constants_js_1.RECOVERY_VALIDATOR_ADDRESS,
            functionName: "getApproval",
            args: [kernelAccountAddress, callDataAndNonceHash],
        });
    }
}
exports.RecoveryProvider = RecoveryProvider;
//# sourceMappingURL=recovery-provider.js.map