"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KernelSmartContractAccount = exports.isKernelAccount = exports.DeploymentState = void 0;
const viem_1 = require("viem");
const KernelAccountAbi_js_1 = require("./abis/KernelAccountAbi.js");
const KernelFactoryAbi_js_1 = require("./abis/KernelFactoryAbi.js");
const aa_core_1 = require("@alchemy/aa-core");
const constants_js_1 = require("./constants.js");
const utils_js_1 = require("./utils.js");
const MultiSendAbi_js_1 = require("./abis/MultiSendAbi.js");
const chains_1 = require("viem/chains");
const index_js_1 = require("./api/index.js");
const create_client_js_1 = require("./client/create-client.js");
var DeploymentState;
(function (DeploymentState) {
    DeploymentState["UNDEFINED"] = "0x0";
    DeploymentState["NOT_DEPLOYED"] = "0x1";
    DeploymentState["DEPLOYED"] = "0x2";
})(DeploymentState || (exports.DeploymentState = DeploymentState = {}));
function isKernelAccount(account) {
    return account && account.connectValidator !== undefined;
}
exports.isKernelAccount = isKernelAccount;
class KernelSmartContractAccount extends aa_core_1.BaseSmartContractAccount {
    constructor(params) {
        super({
            ...params,
            entryPointAddress: params.entryPointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS,
            chain: params.chain ?? chains_1.polygonMumbai,
            rpcClient: params.rpcClient ?? constants_js_1.BUNDLER_URL,
        });
        Object.defineProperty(this, "factoryAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "initCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "defaultValidator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = params.index ?? 0n;
        this.factoryAddress = params.factoryAddress ?? constants_js_1.KERNEL_FACTORY_ADDRESS;
        this.validator = params.validator;
        this.defaultValidator = params.defaultValidator;
        this.initCode = params.initCode;
    }
    static async init(params) {
        const chainId = await (0, index_js_1.getChainId)(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = (0, utils_js_1.getChain)(chainId);
        const rpcClient = typeof params.rpcClient === "string"
            ? (0, create_client_js_1.createZeroDevPublicErc4337Client)({
                chain,
                rpcUrl: params.rpcClient,
                bundlerRpcUrl: params.rpcClient ?? constants_js_1.BUNDLER_URL,
                projectId: params.projectId,
                bundlerProvider: params.bundlerProvider,
            })
            : params.rpcClient;
        const instance = new KernelSmartContractAccount({
            ...params,
            chain,
            rpcClient,
        });
        return instance;
    }
    connectValidator(validator) {
        (0, aa_core_1.defineReadOnly)(this, "validator", validator);
        return this;
    }
    getValidator() {
        if (!this.validator) {
            throw new Error("Validator not connected");
        }
        return this.validator;
    }
    getDummySignature() {
        return "0x00000000870fe151d548a1c527c3804866fab30abf28ed17b79d5fc5149f19ca0819fefc3c57f3da4fdf9b10fab3f2f3dca536467ae44943b9dbb8433efe7760ddd72aaa1c";
    }
    async getInitCode() {
        if (this.deploymentState === DeploymentState.DEPLOYED) {
            return "0x";
        }
        const contractCode = await this.rpcProvider.getContractCode(await this.getAddress());
        if ((contractCode?.length ?? 0) > 2) {
            this.deploymentState = DeploymentState.DEPLOYED;
            return "0x";
        }
        else {
            this.deploymentState = DeploymentState.NOT_DEPLOYED;
        }
        return this.initCode ?? this.getAccountInitCode();
    }
    getIndex() {
        return this.index;
    }
    async approvePlugin() {
        if (!this.validator) {
            throw new Error("Validator not connected");
        }
        if (this.defaultValidator && !this.validator.getEnableSignature()) {
            const { executor, selector, validAfter, validUntil } = this.validator.getPluginValidatorData();
            const enableSig = await this.defaultValidator.approveExecutor(await this.getAddress(), selector, executor, validUntil, validAfter, this.validator);
            this.validator.setEnableSignature(enableSig);
        }
    }
    async encodeExecute(target, value, data) {
        if (!this.validator) {
            throw new Error("Validator not connected");
        }
        if (target.toLowerCase() === (await this.getAddress()).toLowerCase() &&
            this.validator.shouldDelegateViaFallback()) {
            return data;
        }
        else {
            return this.encodeExecuteAction(target, value, data, 0);
        }
    }
    async encodeBatchExecute(_txs) {
        const kernelImplAddr = await this.getKernelImplementationAddess();
        const initCode = await this.getInitCode();
        const shouldUseMultiSend = kernelImplAddr?.toLowerCase() !== constants_js_1.KERNEL_IMPL_ADDRESS.toLowerCase() &&
            kernelImplAddr?.toLowerCase() !==
                "0x8dD4DBB54d8A8Cf0DE6F9CCC4609470A30EfF18C".toLowerCase() &&
            kernelImplAddr?.toLowerCase() !==
                "0xd3f582f6b4814e989ee8e96bc3175320b5a540ab".toLowerCase() &&
            initCode === "0x";
        if (shouldUseMultiSend) {
            const multiSendCalldata = (0, viem_1.encodeFunctionData)({
                abi: MultiSendAbi_js_1.MultiSendAbi,
                functionName: "multiSend",
                args: [(0, utils_js_1.encodeMultiSend)(_txs)],
            });
            return await this.encodeExecuteDelegate(constants_js_1.MULTISEND_ADDR, BigInt(0), multiSendCalldata);
        }
        return await this.encodeExecuteBatchAction(_txs);
    }
    async encodeExecuteDelegate(target, value, data) {
        return this.encodeExecuteAction(target, value, data, 1);
    }
    async encodeSetExection() {
        if (!this.validator) {
            throw new Error("Validator not connected");
        }
        const { executor, selector, validAfter, validUntil } = await this.validator.getPluginValidatorData();
        const enableData = await this.validator.getEnableData();
        return (0, viem_1.encodeFunctionData)({
            abi: KernelAccountAbi_js_1.KernelAccountAbi,
            functionName: "setExecution",
            args: [
                selector,
                executor,
                this.validator.validatorAddress,
                validUntil,
                validAfter,
                enableData,
            ],
        });
    }
    async encodeUgradeTo() {
        return (0, viem_1.encodeFunctionData)({
            abi: KernelAccountAbi_js_1.KernelAccountAbi,
            functionName: "upgradeTo",
            args: [constants_js_1.KERNEL_IMPL_ADDRESS],
        });
    }
    async getKernelImplementationAddess() {
        try {
            const strgAddr = await this.rpcProvider.getStorageAt({
                address: await this.getAddress(),
                slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
            });
            return strgAddr ? ("0x" + strgAddr.slice(26)) : strgAddr;
        }
        catch (error) {
            return;
        }
    }
    async signMessageWith6492(msg) {
        try {
            if (!this.validator) {
                throw new Error("Validator not connected");
            }
            const formattedMessage = typeof msg === "string" ? (0, viem_1.toBytes)(msg) : msg;
            let signature = await this.validator.signMessage((0, viem_1.toBytes)((0, viem_1.hashMessage)({ raw: formattedMessage })));
            if (!(await this.isAccountDeployed())) {
                signature = (0, aa_core_1.wrapWith6492)({
                    factoryAddress: this.factoryAddress,
                    initCode: await this.getFactoryInitCode(),
                    signature,
                });
            }
            return signature;
        }
        catch (err) {
            console.error("Got Error - ", err.message);
            throw new Error("Message Signing with EIP6492 failed");
        }
    }
    async signTypedDataWith6492(params) {
        try {
            if (!this.validator) {
                throw new Error("Validator not connected");
            }
            let signature = await this.validator.signTypedData(params);
            if (!(await this.isAccountDeployed())) {
                signature = (0, aa_core_1.wrapWith6492)({
                    factoryAddress: this.factoryAddress,
                    initCode: await this.getFactoryInitCode(),
                    signature,
                });
            }
            return signature;
        }
        catch (err) {
            console.error("Got Error - ", err.message);
            throw new Error("Message Signing with EIP6492 failed");
        }
    }
    async signMessage(msg) {
        if (!this.validator) {
            throw new Error("Validator not connected");
        }
        const formattedMessage = typeof msg === "string" ? (0, viem_1.toBytes)(msg) : msg;
        return await this.validator.signMessage(formattedMessage);
    }
    async signTypedData(params) {
        if (!this.validator) {
            throw new Error("Validator not connected");
        }
        return await this.validator.signTypedData(params);
    }
    signUserOp(userOp) {
        if (!this.validator) {
            throw new Error("Validator not connected");
        }
        return this.validator.signUserOp(userOp);
    }
    encodeExecuteAction(target, value, data, code) {
        return (0, viem_1.encodeFunctionData)({
            abi: KernelAccountAbi_js_1.KernelAccountAbi,
            functionName: "execute",
            args: [target, value, data, code],
        });
    }
    encodeExecuteBatchAction(_txs) {
        return (0, viem_1.encodeFunctionData)({
            abi: KernelAccountAbi_js_1.KernelAccountAbi,
            functionName: "executeBatch",
            args: [
                _txs.map((tx) => ({
                    to: tx.target,
                    value: tx.value ?? 0n,
                    data: tx.data,
                })),
            ],
        });
    }
    async getAccountInitCode() {
        return (0, viem_1.concatHex)([this.factoryAddress, await this.getFactoryInitCode()]);
    }
    async getNonce() {
        if (!(await this.isAccountDeployed())) {
            return 0n;
        }
        if (!this.validator) {
            throw Error("Validator unintialized");
        }
        const address = await this.getAddress();
        const key = this.validator.getNonceKey();
        return this.entryPoint.read.getNonce([address, key]);
    }
    async getFactoryInitCode() {
        const validator = this.defaultValidator ?? this.validator;
        if (!validator) {
            throw new Error("Validator not connected");
        }
        try {
            return (0, viem_1.encodeFunctionData)({
                abi: KernelFactoryAbi_js_1.KernelFactoryAbi,
                functionName: "createAccount",
                args: [
                    constants_js_1.KERNEL_IMPL_ADDRESS,
                    (0, viem_1.encodeFunctionData)({
                        abi: KernelAccountAbi_js_1.KernelAccountAbi,
                        functionName: "initialize",
                        args: [validator.getAddress(), await validator.getEnableData()],
                    }),
                    this.index,
                ],
            });
        }
        catch (err) {
            console.error("err occurred:", err.message);
            throw new Error("Factory Code generation failed");
        }
    }
}
exports.KernelSmartContractAccount = KernelSmartContractAccount;
//# sourceMappingURL=account.js.map