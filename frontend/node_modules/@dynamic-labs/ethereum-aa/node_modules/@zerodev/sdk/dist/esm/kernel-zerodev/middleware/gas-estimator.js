import { deepHexlify, resolveProperties, } from "@alchemy/aa-core";
import { BaseError } from "viem";
import { ENTRYPOINT_ADDRESS } from "../constants.js";
import { calcPreVerificationGas } from "../utils/calc-pre-verification-gas.js";
import {} from "../paymaster/types.js";
export class Eip1559FeesNotSupportedError extends BaseError {
    constructor() {
        super("Chain does not support EIP-1559 fees.");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Eip1559FeesNotSupportedError"
        });
    }
}
export const withZeroDevGasEstimator = (provider) => {
    provider.withFeeDataGetter(async (struct) => {
        let overrides = await resolveProperties({
            maxFeePerGas: struct.maxFeePerGas,
            maxPriorityFeePerGas: struct.maxPriorityFeePerGas,
        });
        if (provider.bundlerProvider === "GELATO") {
            return { maxFeePerGas: 0n, maxPriorityFeePerGas: 0n };
        }
        let maxFeePerGas, maxPriorityFeePerGas;
        try {
            ({ maxFeePerGas, maxPriorityFeePerGas } = await eip1559GasPrice(provider));
        }
        catch (error) {
            console.warn("getGas: eth_maxPriorityFeePerGas failed, falling back to legacy gas price.");
        }
        if (maxFeePerGas === undefined || maxPriorityFeePerGas === undefined) {
            const feeData = await getFeeData(provider);
            maxFeePerGas = feeData?.maxFeePerGas ? BigInt(feeData?.maxFeePerGas) : 0n;
            maxPriorityFeePerGas = feeData.maxPriorityFeePerGas
                ? BigInt(feeData.maxPriorityFeePerGas)
                : 0n;
        }
        if (overrides.maxFeePerGas || overrides.maxPriorityFeePerGas) {
            return {
                maxFeePerGas: overrides.maxFeePerGas ?? maxFeePerGas,
                maxPriorityFeePerGas: overrides.maxPriorityFeePerGas ?? maxPriorityFeePerGas,
            };
        }
        return { maxFeePerGas, maxPriorityFeePerGas };
    });
    provider.withGasEstimator(async (struct) => {
        if (struct.callGasLimit !== undefined &&
            struct.verificationGasLimit !== undefined &&
            struct.preVerificationGas !== undefined) {
            return struct;
        }
        const initCode = await provider.account?.getInitCode();
        const initGas = await estimateCreationGas(provider, initCode);
        const partialStruct = {
            ...struct,
            callGasLimit: initCode !== undefined && initCode.length > 2
                ? BigInt("1000000")
                : BigInt(55000),
            verificationGasLimit: BigInt(110000) + initGas,
            preVerificationGas: BigInt(100000),
        };
        partialStruct.preVerificationGas = await getPreVerificationGas(partialStruct);
        const request = deepHexlify(await resolveProperties(partialStruct));
        let userOpGasEstimates;
        userOpGasEstimates = await provider.rpcClient.estimateUserOperationGas(request, ENTRYPOINT_ADDRESS);
        const { preVerificationGas, verificationGasLimit, callGasLimit } = userOpGasEstimates;
        request.preVerificationGas =
            BigInt(preVerificationGas) ?? request.preVerificationGas;
        request.verificationGasLimit =
            BigInt(verificationGasLimit) ?? request.verificationGasLimit;
        request.callGasLimit = BigInt(callGasLimit) ?? request.callGasLimit;
        return {
            ...struct,
            ...request,
        };
    });
    return provider;
};
export const estimateCreationGas = async (provider, initCode) => {
    if (initCode == null || initCode === "0x")
        return BigInt(0);
    const deployerAddress = initCode.substring(0, 42);
    const deployerCallData = ("0x" + initCode.substring(42));
    return await provider.rpcClient.estimateGas({
        account: ENTRYPOINT_ADDRESS,
        to: deployerAddress,
        data: deployerCallData,
    });
};
export const getPreVerificationGas = async (userOp) => {
    const p = await resolveProperties(userOp);
    return calcPreVerificationGas(p);
};
export const GAS_PRICE_RPC_METHODS_BY_BUNDLER = {
    STACKUP: "eth_maxPriorityFeePerGas",
    ALCHEMY: "rundler_maxPriorityFeePerGas",
    PIMLICO: "pimlico_getUserOperationGasPrice",
    GELATO: "eth_maxPriorityFeePerGas",
};
export const eip1559GasPrice = async (provider) => {
    let [fee, block] = await Promise.all([
        provider.rpcClient.request({
            method: GAS_PRICE_RPC_METHODS_BY_BUNDLER[provider.bundlerProvider] ??
                "eth_maxPriorityFeePerGas",
            params: [],
        }),
        provider.rpcClient.getBlock({ blockTag: "latest" }),
    ]);
    if (provider.bundlerProvider === "PIMLICO") {
        fee = fee.standard.maxPriorityFeePerGas;
    }
    if (typeof block.baseFeePerGas !== "bigint")
        throw new Eip1559FeesNotSupportedError();
    const baseFeeMultiplier = 1.2;
    const decimals = baseFeeMultiplier.toString().split(".")[1].length;
    const denominator = 10 ** decimals;
    const multiply = (base) => (base * BigInt(baseFeeMultiplier * denominator)) / BigInt(denominator);
    const maxPriorityFeePerGas = BigInt(fee);
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas;
    return { maxFeePerGas, maxPriorityFeePerGas };
};
export const getFeeData = async (provider) => {
    const { block, gasPrice } = await resolveProperties({
        block: provider.rpcClient.getBlock({ blockTag: "latest" }),
        gasPrice: provider.rpcClient.getGasPrice().catch((error) => {
            console.warn("Legacy: Failed to get gas price", error);
            return null;
        }),
    });
    let maxFeePerGas = null;
    let maxPriorityFeePerGas = null;
    if (block && block.baseFeePerGas != null) {
        const minimumTip = BigInt("1500000000");
        maxPriorityFeePerGas = gasPrice ? gasPrice - block.baseFeePerGas : null;
        if (maxPriorityFeePerGas == null ||
            maxPriorityFeePerGas - BigInt(0) ||
            maxPriorityFeePerGas > minimumTip) {
            maxPriorityFeePerGas = minimumTip;
        }
        maxPriorityFeePerGas =
            maxPriorityFeePerGas < provider.minPriorityFeePerBid
                ? provider.minPriorityFeePerBid
                : maxPriorityFeePerGas;
        maxFeePerGas =
            block.baseFeePerGas * BigInt(2) + (maxPriorityFeePerGas ?? 0);
    }
    return { maxFeePerGas, maxPriorityFeePerGas };
};
//# sourceMappingURL=gas-estimator.js.map