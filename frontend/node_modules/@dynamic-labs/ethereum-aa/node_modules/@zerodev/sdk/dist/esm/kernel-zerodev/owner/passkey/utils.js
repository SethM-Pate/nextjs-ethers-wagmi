import { browserInit, TurnkeyApi } from "@turnkey/http";
import axios from "axios";
import { API_URL } from "../../constants.js";
import { hashTypedData, signatureToHex, hashMessage } from "viem";
browserInit({
    baseUrl: "https://api.turnkey.com",
});
export const abortController = {
    controller: new AbortController(),
};
export function abortWebauthn() {
    abortController.controller.abort("ZeroDev: Reset previous Webauthn request");
    abortController.controller = new AbortController();
}
export const publicKey = "public-key";
export const es256 = -7;
export const generateRandomBuffer = () => {
    const arr = new Uint8Array(32);
    crypto.getRandomValues(arr);
    return arr.buffer;
};
export const base64UrlEncode = (challenge) => {
    return Buffer.from(challenge)
        .toString("base64")
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=/g, "");
};
export const signMessageImplementation = async (msg, id, walletId, projectId, credentialId, apiUrl = API_URL) => {
    abortWebauthn();
    const signedRequest = await TurnkeyApi.signSignRawPayload({
        body: {
            type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD",
            organizationId: id,
            parameters: {
                privateKeyId: walletId,
                payload: msg,
                encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                hashFunction: "HASH_FUNCTION_NO_OP",
            },
            timestampMs: String(Date.now()),
        },
    }, {
        publicKey: {
            allowCredentials: [
                {
                    id: base64URLStringToBuffer(credentialId),
                    type: publicKey,
                },
            ],
        },
    });
    const proxyResponse = await axios.post(`${apiUrl}/projects/${projectId}/wallets/proxy`, {
        signedRequest,
    });
    const { activity } = await proxyResponse.data;
    if (activity.status === "ACTIVITY_STATUS_COMPLETED") {
        let result = activity?.result?.signRawPayloadResult;
        if (result) {
            const signatureHex = signatureToHex({
                r: `0x${result.r}`,
                s: `0x${result.s}`,
                v: result.v === "00" ? 27n : 28n,
            });
            if (signatureHex) {
                return signatureHex;
            }
        }
    }
    return "0x";
};
export const signMessage = async (msg, id, walletId, projectId, credentialId, apiUrl = API_URL) => {
    return await signMessageImplementation(hashMessage(typeof msg === "string" ? msg : { raw: msg }), id, walletId, projectId, credentialId, apiUrl);
};
export const signTypedData = async (params, id, walletId, projectId, credentialId, apiUrl = API_URL) => {
    const hashToSign = hashTypedData(params);
    return await signMessageImplementation(hashToSign, id, walletId, projectId, credentialId, apiUrl);
};
export const getCredentials = async (projectId, name, apiUrl = API_URL) => {
    const url = `${apiUrl}/projects/${projectId}/wallets` + (name ? `/${name}` : "");
    const response = await axios.get(url);
    const credentials = response.data;
    return credentials.map((credential) => ({
        id: base64URLStringToBuffer(credential),
        type: "public-key",
    }));
};
export function base64URLStringToBuffer(base64URLString) {
    const base64 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
    const padLength = (4 - (base64.length % 4)) % 4;
    const padded = base64.padEnd(base64.length + padLength, "=");
    const binary = atob(padded);
    const buffer = new ArrayBuffer(binary.length);
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return buffer;
}
//# sourceMappingURL=utils.js.map