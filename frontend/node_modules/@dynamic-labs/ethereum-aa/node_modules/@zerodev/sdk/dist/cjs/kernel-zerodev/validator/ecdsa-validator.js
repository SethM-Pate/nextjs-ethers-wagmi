"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ECDSAValidator = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const base_js_1 = require("./base.js");
const viem_1 = require("viem");
const ESCDAValidatorAbi_js_1 = require("../abis/ESCDAValidatorAbi.js");
const index_js_1 = require("../api/index.js");
const constants_js_1 = require("../constants.js");
const KernelAccountAbi_js_1 = require("../abis/KernelAccountAbi.js");
const utils_js_1 = require("../utils.js");
class ECDSAValidator extends base_js_1.KernelBaseValidator {
    constructor(params) {
        super(params);
        Object.defineProperty(this, "owner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.owner = params.owner;
    }
    static async init(params) {
        const chainId = await (0, index_js_1.getChainId)(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = (0, utils_js_1.getChain)(chainId);
        const instance = new ECDSAValidator({ ...params, chain });
        return instance;
    }
    async signer() {
        return await Promise.resolve(this.owner);
    }
    async getOwner() {
        return this.owner.getAddress();
    }
    async getEnableData() {
        return this.getOwner();
    }
    encodeEnable(newOwner) {
        return (0, viem_1.encodeFunctionData)({
            abi: ESCDAValidatorAbi_js_1.ECDSAValidatorAbi,
            functionName: "enable",
            args: [newOwner],
        });
    }
    encodeDisable(disableData = "0x") {
        return (0, viem_1.encodeFunctionData)({
            abi: ESCDAValidatorAbi_js_1.ECDSAValidatorAbi,
            functionName: "disable",
            args: [disableData],
        });
    }
    async getDummyUserOpSignature() {
        return constants_js_1.DUMMY_ECDSA_SIG;
    }
    async isPluginEnabled(kernelAccountAddress, selector) {
        if (!this.publicClient) {
            throw new Error("Validator uninitialized: PublicClient missing");
        }
        const execDetail = await this.publicClient.readContract({
            abi: KernelAccountAbi_js_1.KernelAccountAbi,
            address: kernelAccountAddress,
            functionName: "getExecution",
            args: [selector],
        });
        const enableData = await this.publicClient.readContract({
            abi: ESCDAValidatorAbi_js_1.ECDSAValidatorAbi,
            address: this.validatorAddress,
            functionName: "ecdsaValidatorStorage",
            args: [kernelAccountAddress],
        });
        return (execDetail.validator.toLowerCase() ===
            this.validatorAddress.toLowerCase() &&
            enableData.toLowerCase() === (await this.getEnableData()).toLowerCase());
    }
    async signMessage(message) {
        return await this.owner.signMessage(message);
    }
    async signTypedData(params) {
        return (0, utils_js_1.fixSignedData)(await this.owner.signTypedData(params));
    }
    async signUserOp(userOp) {
        if (!this.chain) {
            throw new Error("Validator uninitialized");
        }
        const hash = (0, aa_core_1.getUserOperationHash)({
            ...userOp,
            signature: "0x",
        }, this.entryPointAddress, BigInt(this.chain.id));
        const formattedMessage = typeof hash === "string" ? (0, viem_1.toBytes)(hash) : hash;
        return await this.owner.signMessage(formattedMessage);
    }
}
exports.ECDSAValidator = ECDSAValidator;
//# sourceMappingURL=ecdsa-validator.js.map