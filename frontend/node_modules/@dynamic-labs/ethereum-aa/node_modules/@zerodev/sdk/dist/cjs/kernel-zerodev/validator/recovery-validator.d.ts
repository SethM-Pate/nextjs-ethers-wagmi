import { type Address, type Hex, type SmartAccountSigner, type UserOperationRequest, type SignTypedDataParams } from "@alchemy/aa-core";
import { KernelBaseValidator, type KernelBaseValidatorParams } from "./base.js";
import { type LocalAccount, type WalletClient, type Transport, type Chain, type Account, type PublicClient } from "viem";
import type { EthereumProvider } from "./types.js";
interface WeightedGuardians {
    [guardian: Address]: number;
}
export interface RecoveryValidatorParams extends KernelBaseValidatorParams {
    guardians?: WeightedGuardians;
    threshold?: number;
    delaySeconds?: number;
    accountSigner?: SmartAccountSigner;
    localAccountOrProvider?: LocalAccount<string> | EthereumProvider;
    walletClient?: WalletClient<Transport, Chain>;
    signatures?: Hex;
    recoveryId?: string;
    isSignerSmartContract?: boolean;
}
export type RecoveryConfig = Required<Pick<RecoveryValidatorParams, "guardians" | "threshold" | "delaySeconds">>;
export declare function isLocalAccount(account: any): account is LocalAccount<string>;
export declare function isEthereumProvider(provider: any): provider is EthereumProvider;
type WalletClientAccountType<T> = T extends LocalAccount<string> ? Account : T extends EthereumProvider ? undefined : never;
export declare const recoverySelector: `0x${string}`;
export declare class RecoveryValidator extends KernelBaseValidator {
    protected guardians?: WeightedGuardians;
    protected threshold?: number;
    protected delaySeconds: number;
    protected accountSigner?: SmartAccountSigner;
    protected localAccountOrProvider?: LocalAccount<string> | EthereumProvider;
    protected signatures?: Hex;
    protected recoveryId?: string;
    protected isSignerSmartContract?: boolean;
    walletClient?: WalletClient<Transport, Chain, WalletClientAccountType<typeof this.localAccountOrProvider>>;
    constructor(params: RecoveryValidatorParams);
    static init(params: RecoveryValidatorParams): Promise<RecoveryValidator>;
    getNonceKey(): bigint;
    setRecoverySignatures(signatures: Hex): void;
    getRecoverySignatures(): Promise<Hex | undefined>;
    getRecoveryConfig(): RecoveryConfig;
    signer(): Promise<SmartAccountSigner>;
    getEnableData(): Promise<Hex>;
    encodeEnable(recoveryData: Hex): Hex;
    encodeDisable(disableData?: Hex): Hex;
    encodeApprove(callDataAndNonceHash: Hex, kernelAccountAddress: Address): Hex;
    encodeApproveWithSig(callDataAndNonceHash: Hex, kernelAccountAddress: Address, sigs: Hex): Hex;
    encodeVeto(callDataAndNonceHash: Hex): Hex;
    encodeRenew(guardians: Address[], weights: number[], threshold: number, delay: number): Hex;
    encodeRecoveryAction(enableData: Hex, defaultValidatorAddress: Address): Hex;
    static fetchRecoveryConfigFromContract(kernelAccountAddress: Address, publicClient: PublicClient<Transport, Chain>): Promise<RecoveryConfig>;
    isPluginEnabled(kernelAccountAddress: Address, selector: Hex): Promise<boolean>;
    isGuardiansEnabled(kernelAccountAddress: Address): Promise<boolean>;
    getDummyUserOpSignature(): Promise<Hex>;
    signMessage(message: string | Uint8Array): Promise<Hex>;
    signTypedData(params: SignTypedDataParams): Promise<Hex>;
    signRecoveryHash(recoveryHash: Hex): Promise<Hex>;
    signUserOp(userOp: UserOperationRequest): Promise<Hex>;
}
export {};
