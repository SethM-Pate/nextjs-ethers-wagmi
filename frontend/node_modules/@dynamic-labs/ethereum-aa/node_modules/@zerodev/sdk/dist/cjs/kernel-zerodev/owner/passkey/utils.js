"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64URLStringToBuffer = exports.getCredentials = exports.signTypedData = exports.signMessage = exports.signMessageImplementation = exports.base64UrlEncode = exports.generateRandomBuffer = exports.es256 = exports.publicKey = exports.abortWebauthn = exports.abortController = void 0;
const http_1 = require("@turnkey/http");
const axios_1 = __importDefault(require("axios"));
const constants_js_1 = require("../../constants.js");
const viem_1 = require("viem");
(0, http_1.browserInit)({
    baseUrl: "https://api.turnkey.com",
});
exports.abortController = {
    controller: new AbortController(),
};
function abortWebauthn() {
    exports.abortController.controller.abort("ZeroDev: Reset previous Webauthn request");
    exports.abortController.controller = new AbortController();
}
exports.abortWebauthn = abortWebauthn;
exports.publicKey = "public-key";
exports.es256 = -7;
const generateRandomBuffer = () => {
    const arr = new Uint8Array(32);
    crypto.getRandomValues(arr);
    return arr.buffer;
};
exports.generateRandomBuffer = generateRandomBuffer;
const base64UrlEncode = (challenge) => {
    return Buffer.from(challenge)
        .toString("base64")
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=/g, "");
};
exports.base64UrlEncode = base64UrlEncode;
const signMessageImplementation = async (msg, id, walletId, projectId, credentialId, apiUrl = constants_js_1.API_URL) => {
    abortWebauthn();
    const signedRequest = await http_1.TurnkeyApi.signSignRawPayload({
        body: {
            type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD",
            organizationId: id,
            parameters: {
                privateKeyId: walletId,
                payload: msg,
                encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                hashFunction: "HASH_FUNCTION_NO_OP",
            },
            timestampMs: String(Date.now()),
        },
    }, {
        publicKey: {
            allowCredentials: [
                {
                    id: base64URLStringToBuffer(credentialId),
                    type: exports.publicKey,
                },
            ],
        },
    });
    const proxyResponse = await axios_1.default.post(`${apiUrl}/projects/${projectId}/wallets/proxy`, {
        signedRequest,
    });
    const { activity } = await proxyResponse.data;
    if (activity.status === "ACTIVITY_STATUS_COMPLETED") {
        let result = activity?.result?.signRawPayloadResult;
        if (result) {
            const signatureHex = (0, viem_1.signatureToHex)({
                r: `0x${result.r}`,
                s: `0x${result.s}`,
                v: result.v === "00" ? 27n : 28n,
            });
            if (signatureHex) {
                return signatureHex;
            }
        }
    }
    return "0x";
};
exports.signMessageImplementation = signMessageImplementation;
const signMessage = async (msg, id, walletId, projectId, credentialId, apiUrl = constants_js_1.API_URL) => {
    return await (0, exports.signMessageImplementation)((0, viem_1.hashMessage)(typeof msg === "string" ? msg : { raw: msg }), id, walletId, projectId, credentialId, apiUrl);
};
exports.signMessage = signMessage;
const signTypedData = async (params, id, walletId, projectId, credentialId, apiUrl = constants_js_1.API_URL) => {
    const hashToSign = (0, viem_1.hashTypedData)(params);
    return await (0, exports.signMessageImplementation)(hashToSign, id, walletId, projectId, credentialId, apiUrl);
};
exports.signTypedData = signTypedData;
const getCredentials = async (projectId, name, apiUrl = constants_js_1.API_URL) => {
    const url = `${apiUrl}/projects/${projectId}/wallets` + (name ? `/${name}` : "");
    const response = await axios_1.default.get(url);
    const credentials = response.data;
    return credentials.map((credential) => ({
        id: base64URLStringToBuffer(credential),
        type: "public-key",
    }));
};
exports.getCredentials = getCredentials;
function base64URLStringToBuffer(base64URLString) {
    const base64 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
    const padLength = (4 - (base64.length % 4)) % 4;
    const padded = base64.padEnd(base64.length + padLength, "=");
    const binary = atob(padded);
    const buffer = new ArrayBuffer(binary.length);
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return buffer;
}
exports.base64URLStringToBuffer = base64URLStringToBuffer;
//# sourceMappingURL=utils.js.map