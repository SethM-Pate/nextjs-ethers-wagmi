"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFeeData = exports.eip1559GasPrice = exports.GAS_PRICE_RPC_METHODS_BY_BUNDLER = exports.getPreVerificationGas = exports.estimateCreationGas = exports.withZeroDevGasEstimator = exports.Eip1559FeesNotSupportedError = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const constants_js_1 = require("../constants.js");
const calc_pre_verification_gas_js_1 = require("../utils/calc-pre-verification-gas.js");
class Eip1559FeesNotSupportedError extends viem_1.BaseError {
    constructor() {
        super("Chain does not support EIP-1559 fees.");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Eip1559FeesNotSupportedError"
        });
    }
}
exports.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
const withZeroDevGasEstimator = (provider) => {
    provider.withFeeDataGetter(async (struct) => {
        let overrides = await (0, aa_core_1.resolveProperties)({
            maxFeePerGas: struct.maxFeePerGas,
            maxPriorityFeePerGas: struct.maxPriorityFeePerGas,
        });
        if (provider.bundlerProvider === "GELATO") {
            return { maxFeePerGas: 0n, maxPriorityFeePerGas: 0n };
        }
        let maxFeePerGas, maxPriorityFeePerGas;
        try {
            ({ maxFeePerGas, maxPriorityFeePerGas } = await (0, exports.eip1559GasPrice)(provider));
        }
        catch (error) {
            console.warn("getGas: eth_maxPriorityFeePerGas failed, falling back to legacy gas price.");
        }
        if (maxFeePerGas === undefined || maxPriorityFeePerGas === undefined) {
            const feeData = await (0, exports.getFeeData)(provider);
            maxFeePerGas = feeData?.maxFeePerGas ? BigInt(feeData?.maxFeePerGas) : 0n;
            maxPriorityFeePerGas = feeData.maxPriorityFeePerGas
                ? BigInt(feeData.maxPriorityFeePerGas)
                : 0n;
        }
        if (overrides.maxFeePerGas || overrides.maxPriorityFeePerGas) {
            return {
                maxFeePerGas: overrides.maxFeePerGas ?? maxFeePerGas,
                maxPriorityFeePerGas: overrides.maxPriorityFeePerGas ?? maxPriorityFeePerGas,
            };
        }
        return { maxFeePerGas, maxPriorityFeePerGas };
    });
    provider.withGasEstimator(async (struct) => {
        if (struct.callGasLimit !== undefined &&
            struct.verificationGasLimit !== undefined &&
            struct.preVerificationGas !== undefined) {
            return struct;
        }
        const initCode = await provider.account?.getInitCode();
        const initGas = await (0, exports.estimateCreationGas)(provider, initCode);
        const partialStruct = {
            ...struct,
            callGasLimit: initCode !== undefined && initCode.length > 2
                ? BigInt("1000000")
                : BigInt(55000),
            verificationGasLimit: BigInt(110000) + initGas,
            preVerificationGas: BigInt(100000),
        };
        partialStruct.preVerificationGas = await (0, exports.getPreVerificationGas)(partialStruct);
        const request = (0, aa_core_1.deepHexlify)(await (0, aa_core_1.resolveProperties)(partialStruct));
        let userOpGasEstimates;
        userOpGasEstimates = await provider.rpcClient.estimateUserOperationGas(request, constants_js_1.ENTRYPOINT_ADDRESS);
        const { preVerificationGas, verificationGasLimit, callGasLimit } = userOpGasEstimates;
        request.preVerificationGas =
            BigInt(preVerificationGas) ?? request.preVerificationGas;
        request.verificationGasLimit =
            BigInt(verificationGasLimit) ?? request.verificationGasLimit;
        request.callGasLimit = BigInt(callGasLimit) ?? request.callGasLimit;
        return {
            ...struct,
            ...request,
        };
    });
    return provider;
};
exports.withZeroDevGasEstimator = withZeroDevGasEstimator;
const estimateCreationGas = async (provider, initCode) => {
    if (initCode == null || initCode === "0x")
        return BigInt(0);
    const deployerAddress = initCode.substring(0, 42);
    const deployerCallData = ("0x" + initCode.substring(42));
    return await provider.rpcClient.estimateGas({
        account: constants_js_1.ENTRYPOINT_ADDRESS,
        to: deployerAddress,
        data: deployerCallData,
    });
};
exports.estimateCreationGas = estimateCreationGas;
const getPreVerificationGas = async (userOp) => {
    const p = await (0, aa_core_1.resolveProperties)(userOp);
    return (0, calc_pre_verification_gas_js_1.calcPreVerificationGas)(p);
};
exports.getPreVerificationGas = getPreVerificationGas;
exports.GAS_PRICE_RPC_METHODS_BY_BUNDLER = {
    STACKUP: "eth_maxPriorityFeePerGas",
    ALCHEMY: "rundler_maxPriorityFeePerGas",
    PIMLICO: "pimlico_getUserOperationGasPrice",
    GELATO: "eth_maxPriorityFeePerGas",
};
const eip1559GasPrice = async (provider) => {
    let [fee, block] = await Promise.all([
        provider.rpcClient.request({
            method: exports.GAS_PRICE_RPC_METHODS_BY_BUNDLER[provider.bundlerProvider] ??
                "eth_maxPriorityFeePerGas",
            params: [],
        }),
        provider.rpcClient.getBlock({ blockTag: "latest" }),
    ]);
    if (provider.bundlerProvider === "PIMLICO") {
        fee = fee.standard.maxPriorityFeePerGas;
    }
    if (typeof block.baseFeePerGas !== "bigint")
        throw new Eip1559FeesNotSupportedError();
    const baseFeeMultiplier = 1.2;
    const decimals = baseFeeMultiplier.toString().split(".")[1].length;
    const denominator = 10 ** decimals;
    const multiply = (base) => (base * BigInt(baseFeeMultiplier * denominator)) / BigInt(denominator);
    const maxPriorityFeePerGas = BigInt(fee);
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas;
    return { maxFeePerGas, maxPriorityFeePerGas };
};
exports.eip1559GasPrice = eip1559GasPrice;
const getFeeData = async (provider) => {
    const { block, gasPrice } = await (0, aa_core_1.resolveProperties)({
        block: provider.rpcClient.getBlock({ blockTag: "latest" }),
        gasPrice: provider.rpcClient.getGasPrice().catch((error) => {
            console.warn("Legacy: Failed to get gas price", error);
            return null;
        }),
    });
    let maxFeePerGas = null;
    let maxPriorityFeePerGas = null;
    if (block && block.baseFeePerGas != null) {
        const minimumTip = BigInt("1500000000");
        maxPriorityFeePerGas = gasPrice ? gasPrice - block.baseFeePerGas : null;
        if (maxPriorityFeePerGas == null ||
            maxPriorityFeePerGas - BigInt(0) ||
            maxPriorityFeePerGas > minimumTip) {
            maxPriorityFeePerGas = minimumTip;
        }
        maxPriorityFeePerGas =
            maxPriorityFeePerGas < provider.minPriorityFeePerBid
                ? provider.minPriorityFeePerBid
                : maxPriorityFeePerGas;
        maxFeePerGas =
            block.baseFeePerGas * BigInt(2) + (maxPriorityFeePerGas ?? 0);
    }
    return { maxFeePerGas, maxPriorityFeePerGas };
};
exports.getFeeData = getFeeData;
//# sourceMappingURL=gas-estimator.js.map