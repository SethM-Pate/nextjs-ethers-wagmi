import { encodePacked, fromBytes, toBytes, toHex, isHex, hexToSignature, signatureToHex, } from "viem";
import * as chains from "viem/chains";
import * as customChains from "./utils/custom-chains.js";
import { Signer } from "@ethersproject/abstract-signer";
import { Wallet } from "@ethersproject/wallet";
import { gasTokenChainAddresses } from "./constants.js";
const encodeCall = (_tx) => {
    const data = toBytes(_tx.data);
    const encoded = encodePacked(["uint8", "address", "uint256", "uint256", "bytes"], [
        _tx.delegateCall ? 1 : 0,
        _tx.target,
        _tx.value || BigInt(0),
        BigInt(data.length),
        fromBytes(data, "hex"),
    ]);
    return encoded.slice(2);
};
export const encodeMultiSend = (_txs) => {
    return ("0x" + _txs.map((tx) => encodeCall(tx)).join(""));
};
export function base64ToBytes(base64) {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
export function bytesToBase64(bytes) {
    const binString = Array.from(bytes, (x) => String.fromCodePoint(x)).join("");
    return btoa(binString);
}
export function getGasTokenAddress(gasToken, chainId) {
    if (gasToken === "TEST_ERC20") {
        return "0x3870419Ba2BBf0127060bCB37f69A1b1C090992B";
    }
    return gasTokenChainAddresses[gasToken][chainId] || undefined;
}
export const convertWalletClientToAccountSigner = (client) => {
    return {
        getAddress: async () => Promise.resolve((await client.getAddresses())[0]),
        signMessage: async (message) => (await client.signMessage({
            account: client.account,
            message: typeof message === "string"
                ? message
                : {
                    raw: message,
                },
        })),
        signTypedData: async (params) => fixSignedData(await client.signTypedData({ ...params, account: client.account })),
    };
};
export const isWallet = (signer) => signer && signer._signTypedData !== undefined;
export const convertEthersSignerToAccountSigner = (signer) => {
    return {
        getAddress: async () => Promise.resolve((await signer.getAddress())),
        signMessage: async (msg) => (await signer.signMessage(msg)),
        signTypedData: async (params) => {
            if (!isWallet(signer)) {
                throw Error("signTypedData method not implemented in signer");
            }
            return fixSignedData((await signer._signTypedData(params.domain, params.types, params.message)));
        },
    };
};
export const randomHexString = (length) => toHex(Array.from({ length }, () => Math.floor(Math.random() * 16).toString(16)).join(""));
export const fixSignedData = (sig) => {
    let signature = sig;
    if (!isHex(signature)) {
        signature = `0x${signature}`;
        if (!isHex(signature)) {
            throw new Error("Invalid signed data " + sig);
        }
    }
    let { r, s, v } = hexToSignature(signature);
    if (v === 0n || v === 1n)
        v += 27n;
    const joined = signatureToHex({ r, s, v });
    return joined;
};
export const getChain = (chainId) => {
    for (const chain of Object.values(chains).concat(Object.values(customChains))) {
        if (chain.id === chainId) {
            return chain;
        }
    }
    throw new Error("could not find chain");
};
//# sourceMappingURL=utils.js.map