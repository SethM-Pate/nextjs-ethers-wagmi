"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecoveryValidator = exports.recoverySelector = exports.isEthereumProvider = exports.isLocalAccount = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const base_js_1 = require("./base.js");
const viem_1 = require("viem");
const WeightedValidatorAbi_js_1 = require("../abis/WeightedValidatorAbi.js");
const index_js_1 = require("../api/index.js");
const constants_js_1 = require("../constants.js");
const KernelAccountAbi_js_1 = require("../abis/KernelAccountAbi.js");
const utils_js_1 = require("../utils.js");
const chains_1 = require("viem/chains");
const RecoveryActionAbi_js_1 = require("../abis/RecoveryActionAbi.js");
function isLocalAccount(account) {
    return account && account.signTransaction !== undefined;
}
exports.isLocalAccount = isLocalAccount;
function isEthereumProvider(provider) {
    return provider && provider.request !== undefined;
}
exports.isEthereumProvider = isEthereumProvider;
exports.recoverySelector = (0, viem_1.getFunctionSelector)("doRecovery(address, bytes)");
class RecoveryValidator extends base_js_1.KernelBaseValidator {
    constructor(params) {
        super(params);
        Object.defineProperty(this, "guardians", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "threshold", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "delaySeconds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "accountSigner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "localAccountOrProvider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signatures", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recoveryId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isSignerSmartContract", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "walletClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.guardians = params.guardians;
        this.threshold = params.threshold;
        this.delaySeconds = params.delaySeconds ?? 0;
        this.accountSigner = params.accountSigner;
        this.mode = params.mode ?? base_js_1.ValidatorMode.plugin;
        this.localAccountOrProvider = params.localAccountOrProvider;
        this.signatures = params.signatures;
        this.validAfter = params.validAfter ?? 0;
        this.validUntil = params.validUntil ?? 0;
        this.executor = params.executor ?? constants_js_1.RECOVERY_ACTION;
        this.selector = params.selector ?? exports.recoverySelector;
        this.recoveryId = params.recoveryId;
        this.isSignerSmartContract = params.isSignerSmartContract;
        if (isLocalAccount(params.localAccountOrProvider)) {
            this.walletClient = (0, viem_1.createWalletClient)({
                account: params.localAccountOrProvider,
                chain: this.chain ?? chains_1.polygonMumbai,
                transport: (0, viem_1.http)(this.rpcUrl ?? constants_js_1.CHAIN_ID_TO_NODE[this.chain?.id ?? chains_1.polygonMumbai.id]),
            }).extend(viem_1.publicActions);
        }
        else if (isEthereumProvider(params.localAccountOrProvider)) {
            this.walletClient = (0, viem_1.createWalletClient)({
                chain: this.chain ?? chains_1.polygonMumbai,
                transport: (0, viem_1.custom)(params.localAccountOrProvider),
            }).extend(viem_1.publicActions);
        }
        else if (params.walletClient) {
            this.walletClient = params.walletClient.extend(viem_1.publicActions);
        }
        else if (params.localAccountOrProvider) {
            throw Error("Incorrect localAccountOrProvider type");
        }
    }
    static async init(params) {
        const chainId = await (0, index_js_1.getChainId)(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = (0, utils_js_1.getChain)(chainId);
        const instance = new RecoveryValidator({ ...params, chain });
        return instance;
    }
    getNonceKey() {
        return BigInt(this.validatorAddress);
    }
    setRecoverySignatures(signatures) {
        this.signatures = signatures;
    }
    async getRecoverySignatures() {
        if (this.recoveryId) {
            const { signatures } = await (0, index_js_1.getRecoveryData)(this.recoveryId);
            this.setRecoverySignatures(signatures);
        }
        return this.signatures;
    }
    getRecoveryConfig() {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        return {
            guardians: this.guardians,
            threshold: this.threshold,
            delaySeconds: this.delaySeconds,
        };
    }
    async signer() {
        if (!this.accountSigner) {
            throw Error("AccountSigner not set");
        }
        return await Promise.resolve(this.accountSigner);
    }
    async getEnableData() {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        return (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)("address[] guardians, uint24[] weights, uint24 threshold, uint48 delay"), [
            Object.keys(this.guardians),
            Object.values(this.guardians),
            this.threshold,
            this.delaySeconds,
        ]);
    }
    encodeEnable(recoveryData) {
        return (0, viem_1.encodeFunctionData)({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            functionName: "enable",
            args: [recoveryData],
        });
    }
    encodeDisable(disableData = "0x") {
        return (0, viem_1.encodeFunctionData)({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            functionName: "disable",
            args: [disableData],
        });
    }
    encodeApprove(callDataAndNonceHash, kernelAccountAddress) {
        return (0, viem_1.encodeFunctionData)({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            functionName: "approve",
            args: [callDataAndNonceHash, kernelAccountAddress],
        });
    }
    encodeApproveWithSig(callDataAndNonceHash, kernelAccountAddress, sigs) {
        return (0, viem_1.encodeFunctionData)({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            functionName: "approveWithSig",
            args: [callDataAndNonceHash, kernelAccountAddress, sigs],
        });
    }
    encodeVeto(callDataAndNonceHash) {
        return (0, viem_1.encodeFunctionData)({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            functionName: "veto",
            args: [callDataAndNonceHash],
        });
    }
    encodeRenew(guardians, weights, threshold, delay) {
        return (0, viem_1.encodeFunctionData)({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            functionName: "renew",
            args: [guardians, weights, threshold, delay],
        });
    }
    encodeRecoveryAction(enableData, defaultValidatorAddress) {
        return (0, viem_1.encodeFunctionData)({
            abi: RecoveryActionAbi_js_1.RecoveryActionAbi,
            functionName: "doRecovery",
            args: [defaultValidatorAddress, enableData],
        });
    }
    static async fetchRecoveryConfigFromContract(kernelAccountAddress, publicClient) {
        try {
            const [, threshold, delaySeconds, firstGuardian] = await publicClient.readContract({
                abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
                address: constants_js_1.RECOVERY_VALIDATOR_ADDRESS,
                functionName: "weightedStorage",
                args: [kernelAccountAddress],
            });
            const guardians = {};
            let nextGuardian = firstGuardian;
            const sentinelValue = "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";
            while (nextGuardian.toLowerCase() !== sentinelValue.toLowerCase()) {
                const guardianStorage = await publicClient.readContract({
                    abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
                    address: constants_js_1.RECOVERY_VALIDATOR_ADDRESS,
                    functionName: "guardian",
                    args: [nextGuardian, kernelAccountAddress],
                });
                guardians[nextGuardian] = guardianStorage[0];
                nextGuardian = guardianStorage[1];
            }
            return {
                threshold,
                delaySeconds,
                guardians,
            };
        }
        catch (error) {
            throw Error("Failed to fetch config from contract");
        }
    }
    async isPluginEnabled(kernelAccountAddress, selector) {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        if (!this.publicClient) {
            throw new Error("Validator uninitialized: PublicClient missing");
        }
        try {
            const kernel = (0, viem_1.getContract)({
                abi: KernelAccountAbi_js_1.KernelAccountAbi,
                address: kernelAccountAddress,
                publicClient: this.publicClient,
            });
            const execDetail = await kernel.read.getExecution([selector]);
            const enableData = await this.publicClient.readContract({
                abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
                address: this.validatorAddress,
                functionName: "weightedStorage",
                args: [kernelAccountAddress],
            });
            return (execDetail.validator.toLowerCase() ===
                this.validatorAddress.toLowerCase() &&
                enableData[0] ===
                    Object.values(this.guardians).reduce((a, c) => a + c, 0) &&
                enableData[1] === this.threshold &&
                enableData[2] === this.delaySeconds &&
                this.isGuardiansEnabled(kernelAccountAddress));
        }
        catch (error) {
            return false;
        }
    }
    async isGuardiansEnabled(kernelAccountAddress) {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        const weightedValidator = (0, viem_1.getContract)({
            abi: WeightedValidatorAbi_js_1.WeightedValidatorAbi,
            address: this.validatorAddress,
            publicClient: this.publicClient,
        });
        for (const [addr, weight] of Object.entries(this.guardians)) {
            const result = await weightedValidator.read.guardian([
                addr,
                kernelAccountAddress,
            ]);
            if (result[0] !== weight) {
                return false;
            }
        }
        return true;
    }
    async getDummyUserOpSignature() {
        let dummySignature = "0x";
        if (this.signatures) {
            const totalSigs = this.signatures.substring(2).length / 130;
            for (let i = 0; i < totalSigs; i++) {
                dummySignature = (0, viem_1.concatHex)([dummySignature, constants_js_1.DUMMY_ECDSA_SIG]);
            }
            return this.signatures;
        }
        return constants_js_1.DUMMY_ECDSA_SIG;
    }
    async signMessage(message) {
        if (!this.accountSigner) {
            throw Error("AccountSigner not set");
        }
        return await this.accountSigner.signMessage(message);
    }
    async signTypedData(params) {
        if (!this.accountSigner) {
            throw Error("AccountSigner not set");
        }
        return (0, utils_js_1.fixSignedData)(await this.accountSigner.signTypedData(params));
    }
    async signRecoveryHash(recoveryHash) {
        if (!this.chain) {
            throw new Error("Validator uninitialized");
        }
        return await this.signTypedData({
            domain: {
                name: "WeightedECDSAValidator",
                version: "0.0.3",
                chainId: this.chain.id,
                verifyingContract: this.validatorAddress,
            },
            types: {
                Approve: [{ name: "callDataAndNonceHash", type: "bytes32" }],
            },
            message: {
                callDataAndNonceHash: recoveryHash,
            },
            primaryType: "Approve",
        });
    }
    async signUserOp(userOp) {
        if (!this.chain) {
            throw new Error("Validator uninitialized");
        }
        if (this.isSignerSmartContract) {
            return this.signatures ?? constants_js_1.DUMMY_ECDSA_SIG;
        }
        const hash = (0, aa_core_1.getUserOperationHash)({
            ...userOp,
            signature: "0x",
        }, this.entryPointAddress, BigInt(this.chain.id));
        const formattedMessage = typeof hash === "string" ? (0, viem_1.toBytes)(hash) : hash;
        return await this.signMessage(formattedMessage);
    }
}
exports.RecoveryValidator = RecoveryValidator;
//# sourceMappingURL=recovery-validator.js.map