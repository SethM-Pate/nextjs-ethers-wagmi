import { getUserOperationHash, } from "@alchemy/aa-core";
import { KernelBaseValidator, ValidatorMode, } from "./base.js";
import { concatHex, encodeAbiParameters, encodeFunctionData, getContract, parseAbiParameters, createWalletClient, http, custom, publicActions, getFunctionSelector, toBytes, } from "viem";
import { WeightedValidatorAbi } from "../abis/WeightedValidatorAbi.js";
import { getChainId, getRecoveryData } from "../api/index.js";
import { CHAIN_ID_TO_NODE, DUMMY_ECDSA_SIG, RECOVERY_ACTION, RECOVERY_VALIDATOR_ADDRESS, } from "../constants.js";
import { KernelAccountAbi } from "../abis/KernelAccountAbi.js";
import { fixSignedData, getChain } from "../utils.js";
import { polygonMumbai } from "viem/chains";
import { RecoveryActionAbi } from "../abis/RecoveryActionAbi.js";
export function isLocalAccount(account) {
    return account && account.signTransaction !== undefined;
}
export function isEthereumProvider(provider) {
    return provider && provider.request !== undefined;
}
export const recoverySelector = getFunctionSelector("doRecovery(address, bytes)");
export class RecoveryValidator extends KernelBaseValidator {
    constructor(params) {
        super(params);
        Object.defineProperty(this, "guardians", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "threshold", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "delaySeconds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "accountSigner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "localAccountOrProvider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signatures", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recoveryId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isSignerSmartContract", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "walletClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.guardians = params.guardians;
        this.threshold = params.threshold;
        this.delaySeconds = params.delaySeconds ?? 0;
        this.accountSigner = params.accountSigner;
        this.mode = params.mode ?? ValidatorMode.plugin;
        this.localAccountOrProvider = params.localAccountOrProvider;
        this.signatures = params.signatures;
        this.validAfter = params.validAfter ?? 0;
        this.validUntil = params.validUntil ?? 0;
        this.executor = params.executor ?? RECOVERY_ACTION;
        this.selector = params.selector ?? recoverySelector;
        this.recoveryId = params.recoveryId;
        this.isSignerSmartContract = params.isSignerSmartContract;
        if (isLocalAccount(params.localAccountOrProvider)) {
            this.walletClient = createWalletClient({
                account: params.localAccountOrProvider,
                chain: this.chain ?? polygonMumbai,
                transport: http(this.rpcUrl ?? CHAIN_ID_TO_NODE[this.chain?.id ?? polygonMumbai.id]),
            }).extend(publicActions);
        }
        else if (isEthereumProvider(params.localAccountOrProvider)) {
            this.walletClient = createWalletClient({
                chain: this.chain ?? polygonMumbai,
                transport: custom(params.localAccountOrProvider),
            }).extend(publicActions);
        }
        else if (params.walletClient) {
            this.walletClient = params.walletClient.extend(publicActions);
        }
        else if (params.localAccountOrProvider) {
            throw Error("Incorrect localAccountOrProvider type");
        }
    }
    static async init(params) {
        const chainId = await getChainId(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = getChain(chainId);
        const instance = new RecoveryValidator({ ...params, chain });
        return instance;
    }
    getNonceKey() {
        return BigInt(this.validatorAddress);
    }
    setRecoverySignatures(signatures) {
        this.signatures = signatures;
    }
    async getRecoverySignatures() {
        if (this.recoveryId) {
            const { signatures } = await getRecoveryData(this.recoveryId);
            this.setRecoverySignatures(signatures);
        }
        return this.signatures;
    }
    getRecoveryConfig() {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        return {
            guardians: this.guardians,
            threshold: this.threshold,
            delaySeconds: this.delaySeconds,
        };
    }
    async signer() {
        if (!this.accountSigner) {
            throw Error("AccountSigner not set");
        }
        return await Promise.resolve(this.accountSigner);
    }
    async getEnableData() {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        return encodeAbiParameters(parseAbiParameters("address[] guardians, uint24[] weights, uint24 threshold, uint48 delay"), [
            Object.keys(this.guardians),
            Object.values(this.guardians),
            this.threshold,
            this.delaySeconds,
        ]);
    }
    encodeEnable(recoveryData) {
        return encodeFunctionData({
            abi: WeightedValidatorAbi,
            functionName: "enable",
            args: [recoveryData],
        });
    }
    encodeDisable(disableData = "0x") {
        return encodeFunctionData({
            abi: WeightedValidatorAbi,
            functionName: "disable",
            args: [disableData],
        });
    }
    encodeApprove(callDataAndNonceHash, kernelAccountAddress) {
        return encodeFunctionData({
            abi: WeightedValidatorAbi,
            functionName: "approve",
            args: [callDataAndNonceHash, kernelAccountAddress],
        });
    }
    encodeApproveWithSig(callDataAndNonceHash, kernelAccountAddress, sigs) {
        return encodeFunctionData({
            abi: WeightedValidatorAbi,
            functionName: "approveWithSig",
            args: [callDataAndNonceHash, kernelAccountAddress, sigs],
        });
    }
    encodeVeto(callDataAndNonceHash) {
        return encodeFunctionData({
            abi: WeightedValidatorAbi,
            functionName: "veto",
            args: [callDataAndNonceHash],
        });
    }
    encodeRenew(guardians, weights, threshold, delay) {
        return encodeFunctionData({
            abi: WeightedValidatorAbi,
            functionName: "renew",
            args: [guardians, weights, threshold, delay],
        });
    }
    encodeRecoveryAction(enableData, defaultValidatorAddress) {
        return encodeFunctionData({
            abi: RecoveryActionAbi,
            functionName: "doRecovery",
            args: [defaultValidatorAddress, enableData],
        });
    }
    static async fetchRecoveryConfigFromContract(kernelAccountAddress, publicClient) {
        try {
            const [, threshold, delaySeconds, firstGuardian] = await publicClient.readContract({
                abi: WeightedValidatorAbi,
                address: RECOVERY_VALIDATOR_ADDRESS,
                functionName: "weightedStorage",
                args: [kernelAccountAddress],
            });
            const guardians = {};
            let nextGuardian = firstGuardian;
            const sentinelValue = "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";
            while (nextGuardian.toLowerCase() !== sentinelValue.toLowerCase()) {
                const guardianStorage = await publicClient.readContract({
                    abi: WeightedValidatorAbi,
                    address: RECOVERY_VALIDATOR_ADDRESS,
                    functionName: "guardian",
                    args: [nextGuardian, kernelAccountAddress],
                });
                guardians[nextGuardian] = guardianStorage[0];
                nextGuardian = guardianStorage[1];
            }
            return {
                threshold,
                delaySeconds,
                guardians,
            };
        }
        catch (error) {
            throw Error("Failed to fetch config from contract");
        }
    }
    async isPluginEnabled(kernelAccountAddress, selector) {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        if (!this.publicClient) {
            throw new Error("Validator uninitialized: PublicClient missing");
        }
        try {
            const kernel = getContract({
                abi: KernelAccountAbi,
                address: kernelAccountAddress,
                publicClient: this.publicClient,
            });
            const execDetail = await kernel.read.getExecution([selector]);
            const enableData = await this.publicClient.readContract({
                abi: WeightedValidatorAbi,
                address: this.validatorAddress,
                functionName: "weightedStorage",
                args: [kernelAccountAddress],
            });
            return (execDetail.validator.toLowerCase() ===
                this.validatorAddress.toLowerCase() &&
                enableData[0] ===
                    Object.values(this.guardians).reduce((a, c) => a + c, 0) &&
                enableData[1] === this.threshold &&
                enableData[2] === this.delaySeconds &&
                this.isGuardiansEnabled(kernelAccountAddress));
        }
        catch (error) {
            return false;
        }
    }
    async isGuardiansEnabled(kernelAccountAddress) {
        if (this.guardians === undefined ||
            !this.threshold ||
            Object.values(this.guardians).some((v) => v === 0) ||
            Object.values(this.guardians).reduce((a, c) => a + c, 0) < this.threshold) {
            throw Error("Recovery config uninitialised or unexpected");
        }
        const weightedValidator = getContract({
            abi: WeightedValidatorAbi,
            address: this.validatorAddress,
            publicClient: this.publicClient,
        });
        for (const [addr, weight] of Object.entries(this.guardians)) {
            const result = await weightedValidator.read.guardian([
                addr,
                kernelAccountAddress,
            ]);
            if (result[0] !== weight) {
                return false;
            }
        }
        return true;
    }
    async getDummyUserOpSignature() {
        let dummySignature = "0x";
        if (this.signatures) {
            const totalSigs = this.signatures.substring(2).length / 130;
            for (let i = 0; i < totalSigs; i++) {
                dummySignature = concatHex([dummySignature, DUMMY_ECDSA_SIG]);
            }
            return this.signatures;
        }
        return DUMMY_ECDSA_SIG;
    }
    async signMessage(message) {
        if (!this.accountSigner) {
            throw Error("AccountSigner not set");
        }
        return await this.accountSigner.signMessage(message);
    }
    async signTypedData(params) {
        if (!this.accountSigner) {
            throw Error("AccountSigner not set");
        }
        return fixSignedData(await this.accountSigner.signTypedData(params));
    }
    async signRecoveryHash(recoveryHash) {
        if (!this.chain) {
            throw new Error("Validator uninitialized");
        }
        return await this.signTypedData({
            domain: {
                name: "WeightedECDSAValidator",
                version: "0.0.3",
                chainId: this.chain.id,
                verifyingContract: this.validatorAddress,
            },
            types: {
                Approve: [{ name: "callDataAndNonceHash", type: "bytes32" }],
            },
            message: {
                callDataAndNonceHash: recoveryHash,
            },
            primaryType: "Approve",
        });
    }
    async signUserOp(userOp) {
        if (!this.chain) {
            throw new Error("Validator uninitialized");
        }
        if (this.isSignerSmartContract) {
            return this.signatures ?? DUMMY_ECDSA_SIG;
        }
        const hash = getUserOperationHash({
            ...userOp,
            signature: "0x",
        }, this.entryPointAddress, BigInt(this.chain.id));
        const formattedMessage = typeof hash === "string" ? toBytes(hash) : hash;
        return await this.signMessage(formattedMessage);
    }
}
//# sourceMappingURL=recovery-validator.js.map