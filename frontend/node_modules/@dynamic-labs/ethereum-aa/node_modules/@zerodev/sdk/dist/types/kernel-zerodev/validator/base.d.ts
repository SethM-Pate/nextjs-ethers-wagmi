import { type SignTypedDataParams, type SmartAccountSigner, type UserOperationRequest } from "@alchemy/aa-core";
import { type Chain, type Hex, type Address, type PublicClient, type Transport } from "viem";
export declare enum ValidatorMode {
    sudo = "0x00000000",
    plugin = "0x00000001",
    enable = "0x00000002"
}
export interface KernelBaseValidatorParams {
    projectId: string;
    validatorAddress?: Hex;
    mode?: ValidatorMode;
    chain?: Chain;
    entryPointAddress?: Address;
    enableSignature?: Hex;
    validUntil?: number;
    validAfter?: number;
    executor?: Address;
    selector?: Hex;
    rpcUrl?: string;
}
export type ValidatorPluginData = Required<Pick<KernelBaseValidatorParams, "executor" | "selector" | "validAfter" | "validUntil">>;
export declare abstract class KernelBaseValidator {
    readonly validatorAddress: Hex;
    mode: ValidatorMode;
    resolvedMode?: ValidatorMode;
    protected projectId: string;
    protected chain?: Chain;
    protected entryPointAddress: Address;
    protected enableSignature?: Hex;
    protected validUntil: number;
    protected validAfter: number;
    protected executor?: Address;
    protected selector?: Hex;
    protected rpcUrl?: string;
    publicClient?: PublicClient<Transport, Chain>;
    constructor(params: KernelBaseValidatorParams);
    abstract encodeEnable(enableData: Hex): Hex;
    abstract encodeDisable(enableData: Hex): Hex;
    abstract getEnableData(kernelAccountAddress?: Address): Promise<Hex>;
    abstract signMessage(message: Uint8Array | string | Hex): Promise<Hex>;
    abstract signTypedData(params: SignTypedDataParams): Promise<Hex>;
    abstract signUserOp(userOp: UserOperationRequest): Promise<Hex>;
    abstract signer(): Promise<SmartAccountSigner>;
    abstract getDummyUserOpSignature(callData?: Hex): Promise<Hex>;
    abstract isPluginEnabled(kernelAccountAddress: Address, selector: Hex): Promise<boolean>;
    shouldDelegateViaFallback(): boolean;
    getPluginValidatorData(): ValidatorPluginData;
    getNonceKey(): bigint;
    getDynamicDummySignature(kernelAccountAddress: Address, calldata: Hex): Promise<Hex>;
    setEnableSignature(enableSignature: Hex): void;
    getEnableSignature(): Hex | undefined;
    getAddress(): Hex;
    getPublicClient(): PublicClient<Transport, Chain>;
    approveExecutor(kernel: Address, selector: Hex, executor: Address, validUntil: number, validAfter: number, validator: KernelBaseValidator): Promise<Hex>;
    resolveValidatorMode(kernelAccountAddress: Address, callData: Hex): Promise<ValidatorMode>;
    getSignature(userOp: UserOperationRequest): Promise<Hex>;
}
//# sourceMappingURL=base.d.ts.map