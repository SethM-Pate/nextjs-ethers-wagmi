import { EntryPointAbi, } from "@alchemy/aa-core";
import { encodeAbiParameters, parseAbiParameters, keccak256, toHex, } from "viem";
const validateUserOpMethod = "simulateValidation";
const UserOpType = EntryPointAbi.find((entry) => entry.name === validateUserOpMethod)?.inputs[0];
function encode(typevalues, forSignature) {
    const types = typevalues
        .map((typevalue) => typevalue.type === "bytes" && forSignature ? "bytes32" : typevalue.type)
        .join(", ");
    const values = typevalues.map((typevalue) => typevalue.type === "bytes" && forSignature
        ? keccak256(typevalue.val)
        : typevalue.val);
    return encodeAbiParameters(parseAbiParameters(types), values);
}
export function packUserOp(op, forSignature = true) {
    if (forSignature) {
        const userOpType = {
            components: [
                {
                    type: "address",
                    name: "sender",
                },
                {
                    type: "uint256",
                    name: "nonce",
                },
                {
                    type: "bytes",
                    name: "initCode",
                },
                {
                    type: "bytes",
                    name: "callData",
                },
                {
                    type: "uint256",
                    name: "callGasLimit",
                },
                {
                    type: "uint256",
                    name: "verificationGasLimit",
                },
                {
                    type: "uint256",
                    name: "preVerificationGas",
                },
                {
                    type: "uint256",
                    name: "maxFeePerGas",
                },
                {
                    type: "uint256",
                    name: "maxPriorityFeePerGas",
                },
                {
                    type: "bytes",
                    name: "paymasterAndData",
                },
                {
                    type: "bytes",
                    name: "signature",
                },
            ],
            name: "userOp",
            type: "tuple",
        };
        let encoded = encodeAbiParameters(userOpType.components, Object.values({
            ...op,
            signature: "0x",
        }));
        encoded = ("0x" + encoded.slice(66, encoded.length - 64));
        return encoded;
    }
    const typevalues = UserOpType.components.map((c) => ({
        type: c.type,
        val: op[c.name],
    }));
    return encode(typevalues, forSignature);
}
export function isValidRequest(request) {
    return (!!request.callGasLimit &&
        !!request.maxFeePerGas &&
        request.maxPriorityFeePerGas != null &&
        !!request.preVerificationGas &&
        !!request.verificationGasLimit);
}
export const hexifyUserOp = (resolvedUserOp) => {
    return Object.keys(resolvedUserOp)
        .map((key) => {
        let val = resolvedUserOp[key];
        if (typeof val !== "string" || !val.startsWith("0x")) {
            val = toHex(val);
        }
        return [key, val];
    })
        .reduce((set, [k, v]) => ({
        ...set,
        [k]: v,
    }), {});
};
//# sourceMappingURL=ERC4337-utils.js.map