"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexifyUserOp = exports.isValidRequest = exports.packUserOp = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const viem_1 = require("viem");
const validateUserOpMethod = "simulateValidation";
const UserOpType = aa_core_1.EntryPointAbi.find((entry) => entry.name === validateUserOpMethod)?.inputs[0];
function encode(typevalues, forSignature) {
    const types = typevalues
        .map((typevalue) => typevalue.type === "bytes" && forSignature ? "bytes32" : typevalue.type)
        .join(", ");
    const values = typevalues.map((typevalue) => typevalue.type === "bytes" && forSignature
        ? (0, viem_1.keccak256)(typevalue.val)
        : typevalue.val);
    return (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)(types), values);
}
function packUserOp(op, forSignature = true) {
    if (forSignature) {
        const userOpType = {
            components: [
                {
                    type: "address",
                    name: "sender",
                },
                {
                    type: "uint256",
                    name: "nonce",
                },
                {
                    type: "bytes",
                    name: "initCode",
                },
                {
                    type: "bytes",
                    name: "callData",
                },
                {
                    type: "uint256",
                    name: "callGasLimit",
                },
                {
                    type: "uint256",
                    name: "verificationGasLimit",
                },
                {
                    type: "uint256",
                    name: "preVerificationGas",
                },
                {
                    type: "uint256",
                    name: "maxFeePerGas",
                },
                {
                    type: "uint256",
                    name: "maxPriorityFeePerGas",
                },
                {
                    type: "bytes",
                    name: "paymasterAndData",
                },
                {
                    type: "bytes",
                    name: "signature",
                },
            ],
            name: "userOp",
            type: "tuple",
        };
        let encoded = (0, viem_1.encodeAbiParameters)(userOpType.components, Object.values({
            ...op,
            signature: "0x",
        }));
        encoded = ("0x" + encoded.slice(66, encoded.length - 64));
        return encoded;
    }
    const typevalues = UserOpType.components.map((c) => ({
        type: c.type,
        val: op[c.name],
    }));
    return encode(typevalues, forSignature);
}
exports.packUserOp = packUserOp;
function isValidRequest(request) {
    return (!!request.callGasLimit &&
        !!request.maxFeePerGas &&
        request.maxPriorityFeePerGas != null &&
        !!request.preVerificationGas &&
        !!request.verificationGasLimit);
}
exports.isValidRequest = isValidRequest;
const hexifyUserOp = (resolvedUserOp) => {
    return Object.keys(resolvedUserOp)
        .map((key) => {
        let val = resolvedUserOp[key];
        if (typeof val !== "string" || !val.startsWith("0x")) {
            val = (0, viem_1.toHex)(val);
        }
        return [key, val];
    })
        .reduce((set, [k, v]) => ({
        ...set,
        [k]: v,
    }), {});
};
exports.hexifyUserOp = hexifyUserOp;
//# sourceMappingURL=ERC4337-utils.js.map