"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionKeyProvider = void 0;
const base_js_1 = require("./base.js");
const session_key_validator_js_1 = require("../validator/session-key-validator.js");
const aa_core_1 = require("@alchemy/aa-core");
const index_js_1 = require("../api/index.js");
const chains_1 = require("viem/chains");
const constants_js_1 = require("../constants.js");
const utils_js_1 = require("../utils.js");
class SessionKeyProvider extends base_js_1.ValidatorProvider {
    constructor(params) {
        const chain = typeof params.opts?.providerConfig?.chain === "number"
            ? (0, utils_js_1.getChain)(params.opts.providerConfig.chain)
            : params.opts?.providerConfig?.chain ?? chains_1.polygonMumbai;
        const validator = new session_key_validator_js_1.SessionKeyValidator({
            projectId: params.projectId,
            sessionKey: params.sessionKey,
            sessionKeyData: params.sessionKeyData,
            chain,
            rpcUrl: params.opts?.providerConfig?.rpcUrl,
            validatorAddress: params.opts?.validatorConfig?.validatorAddress ??
                constants_js_1.SESSION_KEY_VALIDATOR_ADDRESS,
            ...params.opts?.validatorConfig,
        });
        super({
            ...params,
            opts: {
                ...params.opts,
                providerConfig: { ...params.opts?.providerConfig, chain },
            },
        }, validator);
        Object.defineProperty(this, "changeSessionKeyData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.sendEnableUserOperation
        });
        Object.defineProperty(this, "deleteSessionKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.sendDisableUserOperation
        });
    }
    static async init(params) {
        const chainId = await (0, index_js_1.getChainId)(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = (0, utils_js_1.getChain)(chainId);
        const instance = new SessionKeyProvider({
            ...params,
            opts: {
                ...params.opts,
                providerConfig: {
                    chain,
                    ...params.opts?.providerConfig,
                },
            },
        });
        return instance;
    }
    static async fromSessionKeyParams(params, signer) {
        let sessionKey = signer;
        if (!sessionKey) {
            sessionKey = aa_core_1.LocalAccountSigner.privateKeyToAccountSigner(params.sessionKeyParams.sessionPrivateKey);
        }
        return await SessionKeyProvider.init({
            ...params,
            sessionKey,
            sessionKeyData: params.sessionKeyParams.sessionKeyData,
            opts: {
                ...params.opts,
                accountConfig: {
                    ...params.opts?.accountConfig,
                    accountAddress: params.sessionKeyParams.accountAddress,
                    initCode: params.sessionKeyParams.initCode,
                },
                validatorConfig: {
                    ...params.opts?.validatorConfig,
                    executor: params.sessionKeyParams.executor,
                    selector: params.sessionKeyParams.selector,
                    enableSignature: params.sessionKeyParams.enableSignature,
                },
            },
        });
    }
    async serializeSessionKeyParams(sessionPrivateKey) {
        await this.getAccount().approvePlugin();
        let sessionKeyParams = this.getValidator().getSessionData();
        const initCode = await this.getAccount().getInitCode();
        const accountAddress = await this.getAddress();
        if (!initCode) {
            throw Error("initCode not set");
        }
        sessionKeyParams = {
            ...sessionKeyParams,
            sessionPrivateKey,
            initCode,
            accountAddress,
        };
        const jsonString = JSON.stringify(sessionKeyParams);
        const uint8Array = new TextEncoder().encode(jsonString);
        const base64String = (0, utils_js_1.bytesToBase64)(uint8Array);
        return base64String;
    }
    static deserializeSessionKeyParams(sessionKeyParams) {
        const uint8Array = (0, utils_js_1.base64ToBytes)(sessionKeyParams);
        const jsonString = new TextDecoder().decode(uint8Array);
        return JSON.parse(jsonString);
    }
}
exports.SessionKeyProvider = SessionKeyProvider;
//# sourceMappingURL=session-key-provider.js.map