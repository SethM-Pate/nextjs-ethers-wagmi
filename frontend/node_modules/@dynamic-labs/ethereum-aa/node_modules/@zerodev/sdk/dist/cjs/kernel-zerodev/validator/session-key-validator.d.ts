import { type Address, type Hex, type SmartAccountSigner, type UserOperationRequest, type SignTypedDataParams, type Abi } from "@alchemy/aa-core";
import { KernelBaseValidator, type KernelBaseValidatorParams, type ValidatorPluginData } from "./base.js";
import { type GetAbiItemParameters } from "viem";
import { MerkleTree } from "merkletreejs";
import type { GetAbiItemReturnType } from "viem/dist/types/utils/abi/getAbiItem.js";
import type { GeneratePermissionFromArgsParameters } from "./types.js";
import { Operation } from "../provider.js";
export interface SessionKeyValidatorParams extends KernelBaseValidatorParams {
    sessionKey: SmartAccountSigner;
    sessionKeyData: SessionKeyData;
}
export type SessionKeyParams = Pick<SessionKeyValidatorParams, "sessionKeyData" | "enableSignature"> & ValidatorPluginData & {
    sessionPrivateKey?: Hex;
    initCode?: Hex;
    accountAddress?: Address;
};
export declare enum ParamOperator {
    EQUAL = 0,
    GREATER_THAN = 1,
    LESS_THAN = 2,
    GREATER_THAN_OR_EQUAL = 3,
    LESS_THAN_OR_EQUAL = 4,
    NOT_EQUAL = 5
}
export type SessionNonces = {
    lastNonce: bigint;
    invalidNonce: bigint;
};
export type ExecutionRule = {
    validAfter: number;
    interval: number;
    runs: number;
};
export interface ParamRules {
    offset: number;
    condition: ParamOperator;
    param: Hex;
}
export type Permission = {
    target: Address;
    index?: number;
    rules?: ParamRules[];
    sig?: Hex;
    valueLimit?: bigint;
    executionRule?: ExecutionRule;
    operation?: Operation;
};
export interface SessionKeyData {
    validUntil: number;
    validAfter: number;
    paymaster?: Address;
    permissions?: Permission[];
}
export declare function getAbiItem<TAbi extends Abi | readonly unknown[], TItemName extends string>({ abi, args, name, }: GetAbiItemParameters<TAbi, TItemName>): GetAbiItemReturnType<TAbi, TItemName>;
export declare function getPermissionFromABI<TAbi extends Abi | readonly unknown[], TFunctionName extends string | undefined = string>({ abi, target, args, functionName, valueLimit, operation, }: GeneratePermissionFromArgsParameters<TAbi, TFunctionName>): Permission;
export declare class SessionKeyValidator extends KernelBaseValidator {
    protected sessionKey: SmartAccountSigner;
    sessionKeyData: SessionKeyData;
    merkleTree: MerkleTree;
    constructor(params: SessionKeyValidatorParams);
    static init(params: SessionKeyValidatorParams): Promise<SessionKeyValidator>;
    shouldDelegateViaFallback(): boolean;
    findMatchingPermissions(callData: Hex): Permission | Permission[] | undefined;
    private filterPermissions;
    private filterByOperation;
    private filterBySignature;
    private findPermissionByRule;
    private getFormattedHex;
    private evaluateRuleCondition;
    getMerkleTree(): MerkleTree;
    encodePermissionData(permission: Permission | Permission[], merkleProof?: string[] | string[][]): Hex;
    getSessionData(): SessionKeyParams;
    signer(): Promise<SmartAccountSigner>;
    getSessionNonces(kernelAccountAddress: Address): Promise<SessionNonces>;
    getEnableData(kernelAccountAddress?: Address, enabledLastNonce?: bigint): Promise<Hex>;
    isPluginEnabled(kernelAccountAddress: Address, selector: Hex): Promise<boolean>;
    getDummyUserOpSignature(callData: Hex): Promise<Hex>;
    private getEncodedPermissionProofData;
    encodeEnable(sessionKeyEnableData: Hex): Hex;
    encodeDisable(sessionKey: Hex): Hex;
    signMessage(message: string | Uint8Array): Promise<Hex>;
    signTypedData(params: SignTypedDataParams): Promise<Hex>;
    signUserOp(userOp: UserOperationRequest): Promise<Hex>;
}
