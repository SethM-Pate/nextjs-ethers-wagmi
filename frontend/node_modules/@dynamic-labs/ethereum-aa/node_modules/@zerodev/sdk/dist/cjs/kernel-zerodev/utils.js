"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChain = exports.fixSignedData = exports.randomHexString = exports.convertEthersSignerToAccountSigner = exports.isWallet = exports.convertWalletClientToAccountSigner = exports.getGasTokenAddress = exports.bytesToBase64 = exports.base64ToBytes = exports.encodeMultiSend = void 0;
const viem_1 = require("viem");
const chains = __importStar(require("viem/chains"));
const customChains = __importStar(require("./utils/custom-chains.js"));
const constants_js_1 = require("./constants.js");
const encodeCall = (_tx) => {
    const data = (0, viem_1.toBytes)(_tx.data);
    const encoded = (0, viem_1.encodePacked)(["uint8", "address", "uint256", "uint256", "bytes"], [
        _tx.delegateCall ? 1 : 0,
        _tx.target,
        _tx.value || BigInt(0),
        BigInt(data.length),
        (0, viem_1.fromBytes)(data, "hex"),
    ]);
    return encoded.slice(2);
};
const encodeMultiSend = (_txs) => {
    return ("0x" + _txs.map((tx) => encodeCall(tx)).join(""));
};
exports.encodeMultiSend = encodeMultiSend;
function base64ToBytes(base64) {
    const binString = atob(base64);
    return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
exports.base64ToBytes = base64ToBytes;
function bytesToBase64(bytes) {
    const binString = Array.from(bytes, (x) => String.fromCodePoint(x)).join("");
    return btoa(binString);
}
exports.bytesToBase64 = bytesToBase64;
function getGasTokenAddress(gasToken, chainId) {
    if (gasToken === "TEST_ERC20") {
        return "0x3870419Ba2BBf0127060bCB37f69A1b1C090992B";
    }
    return constants_js_1.gasTokenChainAddresses[gasToken][chainId] || undefined;
}
exports.getGasTokenAddress = getGasTokenAddress;
const convertWalletClientToAccountSigner = (client) => {
    return {
        getAddress: async () => Promise.resolve((await client.getAddresses())[0]),
        signMessage: async (message) => (await client.signMessage({
            account: client.account,
            message: typeof message === "string"
                ? message
                : {
                    raw: message,
                },
        })),
        signTypedData: async (params) => (0, exports.fixSignedData)(await client.signTypedData({ ...params, account: client.account })),
    };
};
exports.convertWalletClientToAccountSigner = convertWalletClientToAccountSigner;
const isWallet = (signer) => signer && signer._signTypedData !== undefined;
exports.isWallet = isWallet;
const convertEthersSignerToAccountSigner = (signer) => {
    return {
        getAddress: async () => Promise.resolve((await signer.getAddress())),
        signMessage: async (msg) => (await signer.signMessage(msg)),
        signTypedData: async (params) => {
            if (!(0, exports.isWallet)(signer)) {
                throw Error("signTypedData method not implemented in signer");
            }
            return (0, exports.fixSignedData)((await signer._signTypedData(params.domain, params.types, params.message)));
        },
    };
};
exports.convertEthersSignerToAccountSigner = convertEthersSignerToAccountSigner;
const randomHexString = (length) => (0, viem_1.toHex)(Array.from({ length }, () => Math.floor(Math.random() * 16).toString(16)).join(""));
exports.randomHexString = randomHexString;
const fixSignedData = (sig) => {
    let signature = sig;
    if (!(0, viem_1.isHex)(signature)) {
        signature = `0x${signature}`;
        if (!(0, viem_1.isHex)(signature)) {
            throw new Error("Invalid signed data " + sig);
        }
    }
    let { r, s, v } = (0, viem_1.hexToSignature)(signature);
    if (v === 0n || v === 1n)
        v += 27n;
    const joined = (0, viem_1.signatureToHex)({ r, s, v });
    return joined;
};
exports.fixSignedData = fixSignedData;
const getChain = (chainId) => {
    for (const chain of Object.values(chains).concat(Object.values(customChains))) {
        if (chain.id === chainId) {
            return chain;
        }
    }
    throw new Error("could not find chain");
};
exports.getChain = getChain;
//# sourceMappingURL=utils.js.map