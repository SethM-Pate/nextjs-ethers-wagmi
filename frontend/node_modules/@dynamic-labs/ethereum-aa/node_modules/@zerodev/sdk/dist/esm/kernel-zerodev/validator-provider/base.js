import {} from "@alchemy/aa-core";
import { ZeroDevProvider } from "../provider.js";
import { KernelSmartContractAccount, isKernelAccount, } from "../account.js";
import { polygonMumbai } from "viem/chains";
import { withZeroDevPaymasterAndData } from "../middleware/paymaster.js";
export class ValidatorProvider extends ZeroDevProvider {
    constructor(params, validator) {
        let bundlerProvider = params.bundlerProvider;
        const shouldUsePaymaster = (params.usePaymaster === undefined || params.usePaymaster) &&
            bundlerProvider !== "GELATO";
        if (params.opts?.paymasterConfig &&
            params.opts?.paymasterConfig.policy === "TOKEN_PAYMASTER" &&
            shouldUsePaymaster) {
            bundlerProvider = "STACKUP";
        }
        super({
            ...params.opts?.providerConfig,
            chain: params.opts?.providerConfig?.chain ?? polygonMumbai,
            rpcUrl: params.opts?.providerConfig?.rpcUrl,
            projectId: params.projectId,
            bundlerProvider,
        });
        Object.defineProperty(this, "defaultProvider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "getValidator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                if (!isKernelAccount(this.account) || !this.account.validator) {
                    throw new Error("ValidatorProvider: account with validator is not set, did you call all connects first?");
                }
                return this.account.getValidator();
            }
        });
        Object.defineProperty(this, "getEncodedEnableData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (enableData) => {
                if (!isKernelAccount(this.account) || !this.account.validator) {
                    throw new Error("ValidatorProvider: account with validator is not set, did you call all connects first?");
                }
                return await this.account.validator.encodeEnable(enableData);
            }
        });
        Object.defineProperty(this, "getEncodedDisableData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (disableData = "0x") => {
                if (!isKernelAccount(this.account) || !this.account.validator) {
                    throw new Error("ValidatorProvider: account with validator is not set, did you call all connects first?");
                }
                return await this.account.validator.encodeDisable(disableData);
            }
        });
        Object.defineProperty(this, "sendEnableUserOperation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (enableData) => {
                const encodedEnableData = await this.getEncodedEnableData(enableData);
                if (!isKernelAccount(this.account) || !this.account.validator) {
                    throw new Error("ValidatorProvider: account with validator is not set, did you call all connects first?");
                }
                return await this.sendUserOperation({
                    target: this.account.validator.validatorAddress,
                    data: encodedEnableData,
                });
            }
        });
        Object.defineProperty(this, "sendDisableUserOperation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (disableData = "0x") => {
                const encodedDisableData = await this.getEncodedDisableData(disableData);
                if (!isKernelAccount(this.account) || !this.account.validator) {
                    throw new Error("ValidatorProvider: account with validator is not set, did you call all connects first?");
                }
                if (!this.defaultProvider) {
                    throw Error("Default Validator provider unintialized");
                }
                return await this.defaultProvider.sendUserOperation({
                    target: this.account.validator.validatorAddress,
                    data: encodedDisableData,
                });
            }
        });
        this.defaultProvider = params.defaultProvider;
        if ((typeof params.opts?.providerConfig?.chain === "number" &&
            typeof params.defaultProvider?.chain === "number" &&
            params.opts?.providerConfig?.chain !== params.defaultProvider?.chain) ||
            (typeof params.opts?.providerConfig?.chain === "object" &&
                typeof params.defaultProvider?.chain === "object" &&
                params.opts?.providerConfig?.chain.id !==
                    params.defaultProvider?.chain.id)) {
            throw new Error("chainId mismatch between default provider and current provider - check projectIds");
        }
        this.connect(() => new KernelSmartContractAccount({
            projectId: params.projectId,
            validator,
            defaultValidator: params.defaultProvider?.getValidator(),
            rpcClient: this.rpcClient,
            bundlerProvider,
            index: params.defaultProvider?.getAccount().getIndex(),
            ...params.opts?.accountConfig,
        }));
        if (shouldUsePaymaster) {
            let paymasterConfig = params.opts?.paymasterConfig ?? {
                policy: "VERIFYING_PAYMASTER",
            };
            paymasterConfig = {
                ...paymasterConfig,
                paymasterProvider: params.opts?.paymasterConfig?.paymasterProvider ?? bundlerProvider,
            };
            withZeroDevPaymasterAndData(this, paymasterConfig);
        }
    }
}
//# sourceMappingURL=base.js.map