import {} from "@alchemy/aa-core";
import axios from "axios";
import { toHex, decodeFunctionData, encodeFunctionData, isAddress, } from "viem";
import { ERC20Abi } from "../abis/ERC20Abi.js";
import { KernelAccountAbi } from "../abis/KernelAccountAbi.js";
import { PAYMASTER_URL, ENTRYPOINT_ADDRESS, ERC20_APPROVAL_AMOUNT, MULTISEND_ADDR, } from "../constants.js";
import { AccountNotConnected, IncorrectCallDataForTokenPaymaster, } from "../errors.js";
import { getGasTokenAddress, } from "../utils.js";
import { Paymaster } from "./base.js";
import {} from "./types.js";
import { getChainId } from "../api/index.js";
import { MultiSendAbi } from "../abis/MultiSendAbi.js";
export function isBatchUserOperationCallData(data) {
    return data && Array.isArray(data);
}
export class TokenPaymaster extends Paymaster {
    constructor(provider, paymasterConfig) {
        super(provider);
        Object.defineProperty(this, "paymasterConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: paymasterConfig
        });
    }
    async getPaymasterAddress(paymasterProvider) {
        const chainId = await getChainId(this.provider.getProjectId());
        try {
            const { data: paymasterResp } = await axios.post(`${PAYMASTER_URL}/getPaymasterAddress`, {
                chainId,
                entryPointAddress: ENTRYPOINT_ADDRESS,
                paymasterProvider,
            }, { headers: { "Content-Type": "application/json" } });
            return paymasterResp;
        }
        catch (e) {
            console.log(e);
            return undefined;
        }
    }
    async decodeMainCallFromCallData(kernelAddress, callData) {
        let data = "0x";
        if (callData instanceof Promise) {
            const _data = await callData;
            if (_data instanceof Uint8Array) {
                data = toHex(_data);
            }
            else {
                data = _data;
            }
        }
        else if (callData instanceof Uint8Array) {
            data = toHex(callData);
        }
        else {
            data = callData;
        }
        try {
            const { functionName, args } = decodeFunctionData({
                abi: KernelAccountAbi,
                data: data,
            });
            if (functionName === "execute") {
                const [target, value, data] = args;
                let msFuntionName;
                try {
                    ({ functionName: msFuntionName } = decodeFunctionData({
                        abi: MultiSendAbi,
                        data,
                    }));
                }
                catch (error) { }
                let mainCall = {
                    target,
                    value: value ?? 0n,
                    data,
                };
                if (msFuntionName === "multiSend") {
                    mainCall = {
                        ...mainCall,
                        target: MULTISEND_ADDR,
                        delegateCall: true,
                        data,
                    };
                }
                return mainCall;
            }
            else if (functionName === "executeBatch") {
                const [txs] = args;
                return txs.map((tx) => ({
                    target: tx.to,
                    value: tx.value ?? 0n,
                    data: tx.data,
                }));
            }
        }
        catch (error) {
            return {
                target: (kernelAddress instanceof Promise
                    ? await kernelAddress
                    : kernelAddress),
                data,
                value: 0n,
                delegateCall: true,
            };
        }
        return;
    }
    async getERC20UserOp(struct, mainCall, gasTokenAddress, paymasterAddress) {
        try {
            const approveData = {
                target: gasTokenAddress,
                value: BigInt(0),
                data: encodeFunctionData({
                    abi: ERC20Abi,
                    functionName: "approve",
                    args: [paymasterAddress, ERC20_APPROVAL_AMOUNT[gasTokenAddress]],
                }),
            };
            if (!this.provider.account) {
                throw AccountNotConnected;
            }
            let calls;
            if (isBatchUserOperationCallData(mainCall)) {
                calls = [approveData, ...mainCall];
            }
            else {
                calls = [approveData, mainCall];
            }
            const erc20CallData = await this.provider.account.encodeBatchExecute(calls);
            return {
                ...struct,
                callData: erc20CallData,
                callGasLimit: await this.provider.rpcClient.estimateGas({
                    account: ENTRYPOINT_ADDRESS,
                    to: await this.provider.getAddress(),
                    data: erc20CallData,
                }),
                signature: await this.provider
                    .getAccount()
                    .getValidator()
                    .getDynamicDummySignature((await struct.sender), erc20CallData),
            };
        }
        catch (error) {
            return;
        }
    }
    async getPaymasterResponse(struct, paymasterProvider, shouldOverrideFee, shouldConsume) {
        const mainCall = await this.decodeMainCallFromCallData(struct.sender, struct.callData);
        if (!mainCall) {
            throw IncorrectCallDataForTokenPaymaster;
        }
        const chainId = await getChainId(this.provider.getProjectId());
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const gasTokenAddress = getGasTokenAddress(this.paymasterConfig.gasToken, chainId);
        let paymasterAddress = await this.getPaymasterAddress(paymasterProvider);
        if (gasTokenAddress !== undefined &&
            paymasterAddress !== undefined &&
            isAddress(paymasterAddress)) {
            const erc20UserOp = await this.getERC20UserOp(struct, mainCall, gasTokenAddress, paymasterAddress);
            if (!erc20UserOp) {
                return;
            }
            const paymasterResp = await this.signUserOp({
                userOp: struct,
                callData: struct.callData,
                gasTokenAddress,
                erc20UserOp,
                erc20CallData: erc20UserOp.callData,
                paymasterProvider,
                shouldOverrideFee,
                shouldConsume,
            });
            return paymasterResp;
        }
        return;
    }
}
//# sourceMappingURL=token-paymaster.js.map