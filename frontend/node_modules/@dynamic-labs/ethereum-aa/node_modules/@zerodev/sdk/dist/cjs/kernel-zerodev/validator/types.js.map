{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../src/kernel-zerodev/validator/types.ts"],"names":[],"mappings":"","sourcesContent":["import {\n  type AbiParameter,\n  type AbiParameterKind,\n  type AbiParameterToPrimitiveType,\n  type AbiFunction,\n  type ExtractAbiFunction,\n} from \"abitype\";\nimport { type Pretty } from \"abitype/src/types.js\";\nimport type {\n  ECDSAValidator,\n  ECDSAValidatorParams,\n} from \"./ecdsa-validator.js\";\nimport type {\n  ERC165SessionKeyValidator,\n  ERC165SessionKeyValidatorParams,\n} from \"./erc165-session-key-validator.js\";\n\nimport type {\n  KillSwitchValidator,\n  KillSwitchValidatorParams,\n} from \"./kill-switch-validator.js\";\nimport type {\n  RecoveryValidator,\n  RecoveryValidatorParams,\n} from \"./recovery-validator.js\";\nimport type {\n  SessionKeyValidator,\n  SessionKeyValidatorParams,\n  ParamRules,\n  Permission,\n  SessionKeyData,\n  SessionKeyParams,\n  ParamOperator,\n} from \"./session-key-validator.js\";\nimport type { Abi, InferFunctionName, Narrow } from \"viem\";\n\nexport type SupportedValidators =\n  | \"ECDSA\"\n  | \"KILL_SWITCH\"\n  | \"ERC165_SESSION_KEY\"\n  | \"SESSION_KEY\"\n  | \"RECOVERY\";\n\nexport type ValidatorTypeMap = {\n  ECDSA: ECDSAValidator;\n  KILL_SWITCH: KillSwitchValidator;\n  ERC165_SESSION_KEY: ERC165SessionKeyValidator;\n  SESSION_KEY: SessionKeyValidator;\n  RECOVERY: RecoveryValidator;\n};\n\nexport type ValidatorParamsMap = {\n  ECDSA: ECDSAValidatorParams;\n  KILL_SWITCH: KillSwitchValidatorParams;\n  ERC165_SESSION_KEY: ERC165SessionKeyValidatorParams;\n  SESSION_KEY: SessionKeyValidatorParams;\n  RECOVERY: RecoveryValidatorParams;\n};\n\nexport type ValidatorMap = {\n  [V in SupportedValidators]: new (\n    params: ValidatorParamsMap[V]\n  ) => ValidatorTypeMap[V];\n};\n\nexport type EthereumProvider = { request(...args: any): Promise<any> };\n\nexport type { ParamRules, Permission, SessionKeyData, SessionKeyParams };\n\n// Session Key types\nexport type AbiParametersToPrimitiveTypes<\n  TAbiParameters extends readonly AbiParameter[],\n  TAbiParameterKind extends AbiParameterKind = AbiParameterKind\n> = Pretty<{\n  [K in keyof TAbiParameters]: AbiParameterToPrimitiveType<\n    TAbiParameters[K],\n    TAbiParameterKind\n  >;\n}>;\n\nexport type AbiParametersToConditons<\n  TAbiParameters extends readonly AbiParameter[]\n> = Pretty<{\n  [K in keyof TAbiParameters]: ParamOperator;\n}>;\n\nexport type CombinedArgs<\n  TAbiParameters extends readonly AbiParameter[],\n  TAbiParameterKind extends AbiParameterKind = AbiParameterKind\n> = {\n  [K in keyof TAbiParameters]: {\n    operator: ParamOperator;\n    value: AbiParameterToPrimitiveType<TAbiParameters[K], TAbiParameterKind>;\n  } | null;\n};\n\nexport type GetFunctionArgs<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TAbiFunction extends AbiFunction = TAbi extends Abi\n    ? ExtractAbiFunction<TAbi, TFunctionName>\n    : AbiFunction,\n  TArgs = CombinedArgs<TAbiFunction[\"inputs\"]>,\n  FailedToParseArgs =\n    | ([TArgs] extends [never] ? true : false)\n    | (readonly unknown[] extends TArgs ? true : false)\n> = true extends FailedToParseArgs\n  ? {\n      args?: readonly unknown[];\n    }\n  : TArgs extends readonly []\n  ? { args?: never }\n  : {\n      args?: TArgs;\n    };\n\nexport type GeneratePermissionFromArgsParameters<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = string,\n  _FunctionName = TAbi extends Abi\n    ? InferFunctionName<TAbi, TFunctionName>\n    : never\n> = Pick<Permission, \"target\" | \"valueLimit\" | \"operation\"> & {\n  functionName?: _FunctionName;\n} & (TFunctionName extends string\n    ? { abi: Narrow<TAbi> } & GetFunctionArgs<TAbi, TFunctionName>\n    : _FunctionName extends string\n    ? { abi: [Narrow<TAbi[number]>] } & GetFunctionArgs<TAbi, _FunctionName>\n    : never);\n"]}