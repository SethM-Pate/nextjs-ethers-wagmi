import { getUserOperationHash, } from "@alchemy/aa-core";
import { KernelBaseValidator } from "./base.js";
import { encodeFunctionData, toBytes } from "viem";
import { ECDSAValidatorAbi } from "../abis/ESCDAValidatorAbi.js";
import { getChainId } from "../api/index.js";
import { DUMMY_ECDSA_SIG } from "../constants.js";
import { KernelAccountAbi } from "../abis/KernelAccountAbi.js";
import { fixSignedData, getChain } from "../utils.js";
export class ECDSAValidator extends KernelBaseValidator {
    constructor(params) {
        super(params);
        Object.defineProperty(this, "owner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.owner = params.owner;
    }
    static async init(params) {
        const chainId = await getChainId(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = getChain(chainId);
        const instance = new ECDSAValidator({ ...params, chain });
        return instance;
    }
    async signer() {
        return await Promise.resolve(this.owner);
    }
    async getOwner() {
        return this.owner.getAddress();
    }
    async getEnableData() {
        return this.getOwner();
    }
    encodeEnable(newOwner) {
        return encodeFunctionData({
            abi: ECDSAValidatorAbi,
            functionName: "enable",
            args: [newOwner],
        });
    }
    encodeDisable(disableData = "0x") {
        return encodeFunctionData({
            abi: ECDSAValidatorAbi,
            functionName: "disable",
            args: [disableData],
        });
    }
    async getDummyUserOpSignature() {
        return DUMMY_ECDSA_SIG;
    }
    async isPluginEnabled(kernelAccountAddress, selector) {
        if (!this.publicClient) {
            throw new Error("Validator uninitialized: PublicClient missing");
        }
        const execDetail = await this.publicClient.readContract({
            abi: KernelAccountAbi,
            address: kernelAccountAddress,
            functionName: "getExecution",
            args: [selector],
        });
        const enableData = await this.publicClient.readContract({
            abi: ECDSAValidatorAbi,
            address: this.validatorAddress,
            functionName: "ecdsaValidatorStorage",
            args: [kernelAccountAddress],
        });
        return (execDetail.validator.toLowerCase() ===
            this.validatorAddress.toLowerCase() &&
            enableData.toLowerCase() === (await this.getEnableData()).toLowerCase());
    }
    async signMessage(message) {
        return await this.owner.signMessage(message);
    }
    async signTypedData(params) {
        return fixSignedData(await this.owner.signTypedData(params));
    }
    async signUserOp(userOp) {
        if (!this.chain) {
            throw new Error("Validator uninitialized");
        }
        const hash = getUserOperationHash({
            ...userOp,
            signature: "0x",
        }, this.entryPointAddress, BigInt(this.chain.id));
        const formattedMessage = typeof hash === "string" ? toBytes(hash) : hash;
        return await this.owner.signMessage(formattedMessage);
    }
}
//# sourceMappingURL=ecdsa-validator.js.map