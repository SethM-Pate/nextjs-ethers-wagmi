import { getChainId } from "../api/index.js";
import { BaseSmartContractAccount, defineReadOnly, } from "@alchemy/aa-core";
import { ZeroDevAccountSigner } from "./account-signer.js";
import { JsonRpcProvider } from "@ethersproject/providers";
import { ValidatorProviders } from "../validator-provider/index.js";
import { withZeroDevPaymasterAndData } from "../middleware/paymaster.js";
import { getChain } from "../utils.js";
export class ZeroDevEthersProvider extends JsonRpcProvider {
    constructor(validatorType, params) {
        super();
        Object.defineProperty(this, "accountProvider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "withPaymasterMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (overrides) => {
                this.accountProvider.withPaymasterMiddleware(overrides);
                return this;
            }
        });
        Object.defineProperty(this, "withGasEstimator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.accountProvider.withGasEstimator(override);
                return this;
            }
        });
        Object.defineProperty(this, "withFeeDataGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.accountProvider.withFeeDataGetter(override);
                return this;
            }
        });
        Object.defineProperty(this, "withCustomMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.accountProvider.withCustomMiddleware(override);
                return this;
            }
        });
        let bundlerProvider = params.bundlerProvider;
        const shouldUsePaymaster = (params.usePaymaster === undefined || params.usePaymaster) &&
            bundlerProvider !== "GELATO";
        if (params.opts?.paymasterConfig &&
            params.opts?.paymasterConfig.policy === "TOKEN_PAYMASTER" &&
            shouldUsePaymaster) {
            bundlerProvider = "STACKUP";
        }
        let accountProvider = new ValidatorProviders[validatorType]({
            ...params,
            bundlerProvider,
        });
        if (shouldUsePaymaster) {
            let paymasterConfig = params.opts?.paymasterConfig ?? {
                policy: "VERIFYING_PAYMASTER",
            };
            paymasterConfig = {
                ...paymasterConfig,
                paymasterProvider: params.opts?.paymasterConfig?.paymasterProvider ?? bundlerProvider,
            };
            accountProvider = withZeroDevPaymasterAndData(accountProvider, paymasterConfig);
        }
        this.accountProvider = accountProvider;
    }
    static async init(validatorType, params) {
        const chainId = await getChainId(params.projectId);
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const chain = getChain(chainId);
        const instance = new ZeroDevEthersProvider(validatorType, {
            ...params,
            opts: {
                ...params.opts,
                providerConfig: {
                    chain,
                    ...params.opts?.providerConfig,
                },
            },
        });
        return instance;
    }
    getAccountProvider() {
        return this.accountProvider;
    }
    send(method, params) {
        return this.accountProvider.request({ method, params });
    }
    connectToAccount(fn) {
        defineReadOnly(this, "accountProvider", this.accountProvider.connect(fn));
        return this.getAccountSigner();
    }
    getAccountSigner() {
        return new ZeroDevAccountSigner(this);
    }
    getPublicErc4337Client() {
        return this.accountProvider.rpcClient;
    }
}
//# sourceMappingURL=ethers-provider.js.map