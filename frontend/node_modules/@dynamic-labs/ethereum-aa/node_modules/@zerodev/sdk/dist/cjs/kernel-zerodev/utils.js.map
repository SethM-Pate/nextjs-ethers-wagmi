{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/kernel-zerodev/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  encodePacked,\n  fromBytes,\n  toBytes,\n  type Hex,\n  type WalletClient,\n  toHex,\n  isHex,\n  hexToSignature,\n  signatureToHex,\n} from \"viem\";\nimport * as chains from \"viem/chains\";\nimport * as customChains from \"./utils/custom-chains.js\";\nimport type {\n  SignTypedDataParams,\n  SmartAccountSigner,\n  UserOperationCallData,\n} from \"@alchemy/aa-core\";\nimport { Signer, type TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\nimport type { SupportedGasToken } from \"./paymaster/types.js\";\nimport { gasTokenChainAddresses } from \"./constants.js\";\n\nexport type UserOperationCallDataWithDelegate = UserOperationCallData & {\n  delegateCall?: boolean;\n};\n\nexport type BatchUserOperationCallDataWithDelegate =\n  UserOperationCallDataWithDelegate[];\n\nconst encodeCall = (_tx: UserOperationCallDataWithDelegate): string => {\n  const data = toBytes(_tx.data);\n  const encoded = encodePacked(\n    [\"uint8\", \"address\", \"uint256\", \"uint256\", \"bytes\"],\n    [\n      _tx.delegateCall ? 1 : 0,\n      _tx.target,\n      _tx.value || BigInt(0),\n      BigInt(data.length),\n      fromBytes(data, \"hex\"),\n    ]\n  );\n  return encoded.slice(2);\n};\nexport const encodeMultiSend = (\n  _txs: BatchUserOperationCallDataWithDelegate\n): Hex => {\n  return (\"0x\" + _txs.map((tx) => encodeCall(tx)).join(\"\")) as Hex;\n};\n\nexport function base64ToBytes(base64: string) {\n  const binString = atob(base64);\n  return Uint8Array.from(binString, (m) => m.codePointAt(0) as number);\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  const binString = Array.from(bytes, (x) => String.fromCodePoint(x)).join(\"\");\n  return btoa(binString);\n}\n\nexport function getGasTokenAddress(\n  gasToken: SupportedGasToken,\n  chainId: number\n): Hex | undefined {\n  if (gasToken === \"TEST_ERC20\") {\n    return \"0x3870419Ba2BBf0127060bCB37f69A1b1C090992B\";\n  }\n  return gasTokenChainAddresses[gasToken][chainId] || undefined;\n}\n\nexport const convertWalletClientToAccountSigner = (\n  client: WalletClient\n): SmartAccountSigner => {\n  return {\n    getAddress: async () =>\n      Promise.resolve((await client.getAddresses())[0] as `0x${string}`),\n    signMessage: async (message: Uint8Array | string) =>\n      (await client.signMessage({\n        account: client.account!,\n        message:\n          typeof message === \"string\"\n            ? message\n            : {\n                raw: message,\n              },\n      })) as `0x${string}`,\n    signTypedData: async (params: SignTypedDataParams) =>\n      fixSignedData(\n        await client.signTypedData({ ...params, account: client.account! })\n      ),\n  };\n};\n\nexport const isWallet = (signer: any): signer is Wallet =>\n  signer && signer._signTypedData !== undefined;\n\nexport const convertEthersSignerToAccountSigner = (\n  signer: Signer | Wallet\n): SmartAccountSigner => {\n  return {\n    getAddress: async () =>\n      Promise.resolve((await signer.getAddress()) as `0x${string}`),\n    signMessage: async (msg: Uint8Array | string) =>\n      (await signer.signMessage(msg)) as `0x${string}`,\n    signTypedData: async (params: SignTypedDataParams) => {\n      if (!isWallet(signer)) {\n        throw Error(\"signTypedData method not implemented in signer\");\n      }\n      return fixSignedData(\n        (await signer._signTypedData(\n          params.domain!,\n          params.types as unknown as Record<string, TypedDataField[]>,\n          params.message\n        )) as Hex\n      );\n    },\n  };\n};\n\nexport const randomHexString = (length: number): Hex =>\n  toHex(\n    Array.from({ length }, () =>\n      Math.floor(Math.random() * 16).toString(16)\n    ).join(\"\")\n  );\n\nexport const fixSignedData = (sig: Hex): Hex => {\n  let signature = sig;\n  if (!isHex(signature)) {\n    signature = `0x${signature}`;\n    if (!isHex(signature)) {\n      throw new Error(\"Invalid signed data \" + sig);\n    }\n  }\n\n  let { r, s, v } = hexToSignature(signature);\n  if (v === 0n || v === 1n) v += 27n;\n  const joined = signatureToHex({ r, s, v });\n  return joined;\n};\n\n// Modified from @alchemy/aa-core\n/**\n * Utility method for converting a chainId to a {@link chains.Chain} object\n *\n * @param chainId\n * @returns a {@link chains.Chain} object for the given chainId\n * @throws if the chainId is not found\n */\nexport const getChain = (chainId: number): chains.Chain => {\n  for (const chain of Object.values(chains).concat(\n    Object.values(customChains)\n  )) {\n    if (chain.id === chainId) {\n      return chain;\n    }\n  }\n  throw new Error(\"could not find chain\");\n};\n"]}