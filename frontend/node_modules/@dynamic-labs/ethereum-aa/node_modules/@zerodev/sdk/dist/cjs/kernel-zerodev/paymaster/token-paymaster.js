"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenPaymaster = exports.isBatchUserOperationCallData = void 0;
const axios_1 = __importDefault(require("axios"));
const viem_1 = require("viem");
const ERC20Abi_js_1 = require("../abis/ERC20Abi.js");
const KernelAccountAbi_js_1 = require("../abis/KernelAccountAbi.js");
const constants_js_1 = require("../constants.js");
const errors_js_1 = require("../errors.js");
const utils_js_1 = require("../utils.js");
const base_js_1 = require("./base.js");
const index_js_1 = require("../api/index.js");
const MultiSendAbi_js_1 = require("../abis/MultiSendAbi.js");
function isBatchUserOperationCallData(data) {
    return data && Array.isArray(data);
}
exports.isBatchUserOperationCallData = isBatchUserOperationCallData;
class TokenPaymaster extends base_js_1.Paymaster {
    constructor(provider, paymasterConfig) {
        super(provider);
        Object.defineProperty(this, "paymasterConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: paymasterConfig
        });
    }
    async getPaymasterAddress(paymasterProvider) {
        const chainId = await (0, index_js_1.getChainId)(this.provider.getProjectId());
        try {
            const { data: paymasterResp } = await axios_1.default.post(`${constants_js_1.PAYMASTER_URL}/getPaymasterAddress`, {
                chainId,
                entryPointAddress: constants_js_1.ENTRYPOINT_ADDRESS,
                paymasterProvider,
            }, { headers: { "Content-Type": "application/json" } });
            return paymasterResp;
        }
        catch (e) {
            console.log(e);
            return undefined;
        }
    }
    async decodeMainCallFromCallData(kernelAddress, callData) {
        let data = "0x";
        if (callData instanceof Promise) {
            const _data = await callData;
            if (_data instanceof Uint8Array) {
                data = (0, viem_1.toHex)(_data);
            }
            else {
                data = _data;
            }
        }
        else if (callData instanceof Uint8Array) {
            data = (0, viem_1.toHex)(callData);
        }
        else {
            data = callData;
        }
        try {
            const { functionName, args } = (0, viem_1.decodeFunctionData)({
                abi: KernelAccountAbi_js_1.KernelAccountAbi,
                data: data,
            });
            if (functionName === "execute") {
                const [target, value, data] = args;
                let msFuntionName;
                try {
                    ({ functionName: msFuntionName } = (0, viem_1.decodeFunctionData)({
                        abi: MultiSendAbi_js_1.MultiSendAbi,
                        data,
                    }));
                }
                catch (error) { }
                let mainCall = {
                    target,
                    value: value ?? 0n,
                    data,
                };
                if (msFuntionName === "multiSend") {
                    mainCall = {
                        ...mainCall,
                        target: constants_js_1.MULTISEND_ADDR,
                        delegateCall: true,
                        data,
                    };
                }
                return mainCall;
            }
            else if (functionName === "executeBatch") {
                const [txs] = args;
                return txs.map((tx) => ({
                    target: tx.to,
                    value: tx.value ?? 0n,
                    data: tx.data,
                }));
            }
        }
        catch (error) {
            return {
                target: (kernelAddress instanceof Promise
                    ? await kernelAddress
                    : kernelAddress),
                data,
                value: 0n,
                delegateCall: true,
            };
        }
        return;
    }
    async getERC20UserOp(struct, mainCall, gasTokenAddress, paymasterAddress) {
        try {
            const approveData = {
                target: gasTokenAddress,
                value: BigInt(0),
                data: (0, viem_1.encodeFunctionData)({
                    abi: ERC20Abi_js_1.ERC20Abi,
                    functionName: "approve",
                    args: [paymasterAddress, constants_js_1.ERC20_APPROVAL_AMOUNT[gasTokenAddress]],
                }),
            };
            if (!this.provider.account) {
                throw errors_js_1.AccountNotConnected;
            }
            let calls;
            if (isBatchUserOperationCallData(mainCall)) {
                calls = [approveData, ...mainCall];
            }
            else {
                calls = [approveData, mainCall];
            }
            const erc20CallData = await this.provider.account.encodeBatchExecute(calls);
            return {
                ...struct,
                callData: erc20CallData,
                callGasLimit: await this.provider.rpcClient.estimateGas({
                    account: constants_js_1.ENTRYPOINT_ADDRESS,
                    to: await this.provider.getAddress(),
                    data: erc20CallData,
                }),
                signature: await this.provider
                    .getAccount()
                    .getValidator()
                    .getDynamicDummySignature((await struct.sender), erc20CallData),
            };
        }
        catch (error) {
            return;
        }
    }
    async getPaymasterResponse(struct, paymasterProvider, shouldOverrideFee, shouldConsume) {
        const mainCall = await this.decodeMainCallFromCallData(struct.sender, struct.callData);
        if (!mainCall) {
            throw errors_js_1.IncorrectCallDataForTokenPaymaster;
        }
        const chainId = await (0, index_js_1.getChainId)(this.provider.getProjectId());
        if (!chainId) {
            throw new Error("ChainId not found");
        }
        const gasTokenAddress = (0, utils_js_1.getGasTokenAddress)(this.paymasterConfig.gasToken, chainId);
        let paymasterAddress = await this.getPaymasterAddress(paymasterProvider);
        if (gasTokenAddress !== undefined &&
            paymasterAddress !== undefined &&
            (0, viem_1.isAddress)(paymasterAddress)) {
            const erc20UserOp = await this.getERC20UserOp(struct, mainCall, gasTokenAddress, paymasterAddress);
            if (!erc20UserOp) {
                return;
            }
            const paymasterResp = await this.signUserOp({
                userOp: struct,
                callData: struct.callData,
                gasTokenAddress,
                erc20UserOp,
                erc20CallData: erc20UserOp.callData,
                paymasterProvider,
                shouldOverrideFee,
                shouldConsume,
            });
            return paymasterResp;
        }
        return;
    }
}
exports.TokenPaymaster = TokenPaymaster;
//# sourceMappingURL=token-paymaster.js.map