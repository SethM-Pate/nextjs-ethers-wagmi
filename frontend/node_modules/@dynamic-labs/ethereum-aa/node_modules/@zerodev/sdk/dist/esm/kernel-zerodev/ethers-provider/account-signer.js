import { resolveProperties, } from "@alchemy/aa-core";
import { Signer, } from "@ethersproject/abstract-signer";
import { hexlify } from "@ethersproject/bytes";
import { _TypedDataEncoder } from "@ethersproject/hash";
import {} from "@ethersproject/providers";
import { ZeroDevEthersProvider } from "./ethers-provider.js";
const hexlifyOptional = (value) => {
    if (value == null) {
        return undefined;
    }
    return hexlify(value);
};
export class ZeroDevAccountSigner extends Signer {
    constructor(provider) {
        super();
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: provider
        });
        Object.defineProperty(this, "account", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sendUserOperation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "waitForUserOperationTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "withPaymasterMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (overrides) => {
                this.provider.withPaymasterMiddleware(overrides);
                return this;
            }
        });
        Object.defineProperty(this, "withGasEstimator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.provider.withGasEstimator(override);
                return this;
            }
        });
        Object.defineProperty(this, "withFeeDataGetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.provider.withFeeDataGetter(override);
                return this;
            }
        });
        Object.defineProperty(this, "withCustomMiddleware", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (override) => {
                this.provider.withCustomMiddleware(override);
                return this;
            }
        });
        this.account = this.provider.accountProvider.getAccount();
        this.sendUserOperation =
            this.provider.accountProvider.sendUserOperation.bind(this.provider.accountProvider);
        this.waitForUserOperationTransaction =
            this.provider.accountProvider.waitForUserOperationTransaction.bind(this.provider.accountProvider);
    }
    getAddress() {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        return this.account.getAddress();
    }
    signMessage(message) {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        return this.account.signMessage(message);
    }
    signTypedData(params) {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        if (params.types) {
            delete params.types["EIP712Domain"];
        }
        return this.account.signTypedData(params);
    }
    _signTypedData(domain, types, value) {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        const params = _TypedDataEncoder.getPayload(domain, types, value);
        if (params.types) {
            delete params.types["EIP712Domain"];
        }
        return this.signTypedData(params);
    }
    async signMessageWith6492(_msg) {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        return this.account.signMessageWith6492(_msg);
    }
    async signTypedDataWith6492(params) {
        if (!this.account) {
            throw new Error("connect the signer to a provider that has a connected account");
        }
        return this.account.signTypedDataWith6492(params);
    }
    async sendTransaction(transaction) {
        const resolved = await resolveProperties(transaction);
        const txHash = await this.provider.accountProvider.sendTransaction({
            from: (await this.getAddress()),
            to: resolved.to,
            data: hexlifyOptional(resolved.data),
            value: hexlifyOptional(resolved.value),
        });
        return this.provider.getTransaction(txHash);
    }
    signTransaction(_transaction) {
        throw new Error("Transaction signing is not supported, use sendUserOperation instead");
    }
    getPublicErc4337Client() {
        return this.provider.getPublicErc4337Client();
    }
    connect(provider) {
        return new ZeroDevAccountSigner(provider);
    }
}
//# sourceMappingURL=account-signer.js.map