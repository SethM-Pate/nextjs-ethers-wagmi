{"version":3,"file":"ERC4337-utils.js","sourceRoot":"","sources":["../../../../src/kernel-zerodev/utils/ERC4337-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  EntryPointAbi,\n  type UserOperationRequest,\n  type UserOperationStruct,\n} from \"@alchemy/aa-core\";\nimport type { NotPromise } from \"./calc-pre-verification-gas.js\";\nimport {\n  encodeAbiParameters,\n  parseAbiParameters,\n  type Hex,\n  keccak256,\n  toHex,\n} from \"viem\";\n\n// UserOperation is the first parameter of validateUseOp\nconst validateUserOpMethod = \"simulateValidation\";\n\nconst UserOpType = EntryPointAbi.find(\n  // @ts-ignore\n  (entry) => entry.name === validateUserOpMethod\n  // @ts-ignore\n)?.inputs[0];\n\nfunction encode(\n  typevalues: Array<{ type: string; val: any }>,\n  forSignature: boolean\n): string {\n  const types = typevalues\n    .map((typevalue) =>\n      typevalue.type === \"bytes\" && forSignature ? \"bytes32\" : typevalue.type\n    )\n    .join(\", \");\n  const values = typevalues.map((typevalue) =>\n    typevalue.type === \"bytes\" && forSignature\n      ? keccak256(typevalue.val)\n      : typevalue.val\n  );\n  return encodeAbiParameters(parseAbiParameters(types), values);\n}\n\n/**\n * pack the userOperation\n * @param op\n * @param forSignature \"true\" if the hash is needed to calculate the getUserOpHash()\n *  \"false\" to pack entire UserOp, for calculating the calldata cost of putting it on-chain.\n */\nexport function packUserOp(\n  op: NotPromise<UserOperationStruct>,\n  forSignature = true\n): string {\n  if (forSignature) {\n    // lighter signature scheme (must match UserOperation#pack): do encode a zero-length signature, but strip afterwards the appended zero-length value\n    const userOpType = {\n      components: [\n        {\n          type: \"address\",\n          name: \"sender\",\n        },\n        {\n          type: \"uint256\",\n          name: \"nonce\",\n        },\n        {\n          type: \"bytes\",\n          name: \"initCode\",\n        },\n        {\n          type: \"bytes\",\n          name: \"callData\",\n        },\n        {\n          type: \"uint256\",\n          name: \"callGasLimit\",\n        },\n        {\n          type: \"uint256\",\n          name: \"verificationGasLimit\",\n        },\n        {\n          type: \"uint256\",\n          name: \"preVerificationGas\",\n        },\n        {\n          type: \"uint256\",\n          name: \"maxFeePerGas\",\n        },\n        {\n          type: \"uint256\",\n          name: \"maxPriorityFeePerGas\",\n        },\n        {\n          type: \"bytes\",\n          name: \"paymasterAndData\",\n        },\n        {\n          type: \"bytes\",\n          name: \"signature\",\n        },\n      ],\n      name: \"userOp\",\n      type: \"tuple\",\n    };\n    // console.log('hard-coded userOpType', userOpType)\n    // console.log('from ABI userOpType', UserOpType)\n    let encoded = encodeAbiParameters(\n      userOpType.components,\n      Object.values({\n        ...op,\n        signature: \"0x\",\n      })\n    );\n    // remove leading word (total length) and trailing word (zero-length signature)\n    encoded = (\"0x\" + encoded.slice(66, encoded.length - 64)) as Hex;\n    return encoded;\n  }\n\n  const typevalues = (UserOpType as any).components.map(\n    (c: { name: keyof typeof op; type: string }) => ({\n      type: c.type,\n      val: op[c.name],\n    })\n  );\n  return encode(typevalues, forSignature);\n}\n\n/**\n * Utility method for asserting a {@link UserOperationStruct} is a {@link UserOperationRequest}\n *\n * @param request a {@link UserOperationStruct} to validate\n * @returns a type guard that asserts the {@link UserOperationStruct} is a {@link UserOperationRequest}\n */\nexport function isValidRequest(\n  request: UserOperationStruct\n): request is UserOperationRequest {\n  // These are the only ones marked as optional in the interface above\n  return (\n    !!request.callGasLimit &&\n    !!request.maxFeePerGas &&\n    request.maxPriorityFeePerGas != null &&\n    !!request.preVerificationGas &&\n    !!request.verificationGasLimit\n  );\n}\n\nexport const hexifyUserOp = (resolvedUserOp: any) => {\n  return Object.keys(resolvedUserOp)\n    .map((key) => {\n      let val = resolvedUserOp[key];\n      if (typeof val !== \"string\" || !val.startsWith(\"0x\")) {\n        val = toHex(val);\n      }\n      return [key, val];\n    })\n    .reduce(\n      (set, [k, v]) => ({\n        ...set,\n        [k]: v,\n      }),\n      {}\n    );\n};\n"]}