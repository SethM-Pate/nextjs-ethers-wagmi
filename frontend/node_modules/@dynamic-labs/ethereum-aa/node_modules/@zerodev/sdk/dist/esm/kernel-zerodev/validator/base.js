import {} from "@alchemy/aa-core";
import { concat, pad, toHex, concatHex, hexToBigInt, createPublicClient, http, zeroAddress, } from "viem";
import { KernelAccountAbi } from "../abis/KernelAccountAbi.js";
import { CHAIN_ID_TO_NODE, ECDSA_VALIDATOR_ADDRESS, ENTRYPOINT_ADDRESS, KERNEL_IMPL_ADDRESS, } from "../constants.js";
import { polygonMumbai } from "viem/chains";
export var ValidatorMode;
(function (ValidatorMode) {
    ValidatorMode["sudo"] = "0x00000000";
    ValidatorMode["plugin"] = "0x00000001";
    ValidatorMode["enable"] = "0x00000002";
})(ValidatorMode || (ValidatorMode = {}));
export class KernelBaseValidator {
    constructor(params) {
        Object.defineProperty(this, "validatorAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolvedMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "projectId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "chain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entryPointAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "enableSignature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validUntil", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validAfter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "executor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "selector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rpcUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publicClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.projectId = params.projectId;
        this.validatorAddress = params.validatorAddress ?? ECDSA_VALIDATOR_ADDRESS;
        this.mode = params.mode ?? ValidatorMode.sudo;
        this.entryPointAddress = params.entryPointAddress ?? ENTRYPOINT_ADDRESS;
        this.enableSignature = params.enableSignature;
        this.validUntil = params.validUntil ?? 0;
        this.validAfter = params.validAfter ?? 0;
        this.executor = params.executor;
        this.selector = params.selector;
        this.chain = params.chain;
        this.rpcUrl = params.rpcUrl;
        this.publicClient = createPublicClient({
            transport: http(params.rpcUrl ?? CHAIN_ID_TO_NODE[this.chain?.id ?? polygonMumbai.id]),
            chain: this.chain ?? polygonMumbai,
        });
    }
    shouldDelegateViaFallback() {
        return true;
    }
    getPluginValidatorData() {
        if (!this.selector || !this.executor) {
            throw Error("Plugin Validator data params uninitialised");
        }
        return {
            selector: this.selector,
            executor: this.executor,
            validAfter: this.validAfter,
            validUntil: this.validUntil,
        };
    }
    getNonceKey() {
        return 0n;
    }
    async getDynamicDummySignature(kernelAccountAddress, calldata) {
        const dummyECDSASig = "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
        const validatorMode = this.resolvedMode ??
            (await this.resolveValidatorMode(kernelAccountAddress, calldata));
        if (validatorMode === ValidatorMode.enable) {
            const enableData = await this.getEnableData(kernelAccountAddress);
            const enableDataLength = enableData.length / 2 - 1;
            const enableSigLength = 65;
            const staticDummySig = concatHex([
                "0x000000000000000000000000",
                this.getAddress(),
                this.executor,
            ]);
            return concatHex([
                ValidatorMode.enable,
                staticDummySig,
                pad(toHex(enableDataLength), { size: 32 }),
                enableData,
                pad(toHex(enableSigLength), { size: 32 }),
                dummyECDSASig,
                await this.getDummyUserOpSignature(calldata),
            ]);
        }
        return concatHex([
            validatorMode,
            await this.getDummyUserOpSignature(calldata),
        ]);
    }
    setEnableSignature(enableSignature) {
        this.enableSignature = enableSignature;
    }
    getEnableSignature() {
        return this.enableSignature;
    }
    getAddress() {
        return this.validatorAddress;
    }
    getPublicClient() {
        if (!this.publicClient) {
            throw new Error("Validator uninitialized: PublicClient missing");
        }
        return this.publicClient;
    }
    async approveExecutor(kernel, selector, executor, validUntil, validAfter, validator) {
        if (!this.chain) {
            throw new Error("Validator uninitialized");
        }
        let kernelImplAddr;
        try {
            const strgAddr = await this.getPublicClient().getStorageAt({
                address: kernel,
                slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
            });
            kernelImplAddr = strgAddr
                ? ("0x" + strgAddr.slice(26))
                : strgAddr;
        }
        catch (error) { }
        const sender = kernel;
        const signer = await this.signer();
        const ownerSig = await signer.signTypedData({
            domain: {
                name: "Kernel",
                version: kernelImplAddr?.toLowerCase() === KERNEL_IMPL_ADDRESS.toLowerCase() ||
                    kernelImplAddr?.toLowerCase() ===
                        "0x8dD4DBB54d8A8Cf0DE6F9CCC4609470A30EfF18C".toLowerCase() ||
                    kernelImplAddr === undefined ||
                    kernelImplAddr === zeroAddress
                    ? "0.2.2"
                    : "0.2.1",
                chainId: this.chain.id,
                verifyingContract: sender,
            },
            types: {
                ValidatorApproved: [
                    { name: "sig", type: "bytes4" },
                    { name: "validatorData", type: "uint256" },
                    { name: "executor", type: "address" },
                    { name: "enableData", type: "bytes" },
                ],
            },
            message: {
                sig: selector,
                validatorData: hexToBigInt(concatHex([
                    pad(toHex(validUntil), { size: 6 }),
                    pad(toHex(validAfter), { size: 6 }),
                    validator.getAddress(),
                ]), { size: 32 }),
                executor: executor,
                enableData: await validator.getEnableData(kernel),
            },
            primaryType: "ValidatorApproved",
        });
        return ownerSig;
    }
    async resolveValidatorMode(kernelAccountAddress, callData) {
        if (!this.chain || !this.publicClient) {
            throw new Error("Validator uninitialized");
        }
        let mode;
        try {
            const defaultValidatorAddress = await this.publicClient.readContract({
                abi: KernelAccountAbi,
                address: kernelAccountAddress,
                functionName: "getDefaultValidator",
            });
            if (defaultValidatorAddress?.toLowerCase() ===
                this.validatorAddress.toLowerCase() ||
                this.mode === ValidatorMode.sudo) {
                mode = ValidatorMode.sudo;
            }
            else if (await this.isPluginEnabled(kernelAccountAddress, callData.toString().slice(0, 10))) {
                mode = ValidatorMode.plugin;
            }
            else {
                mode = ValidatorMode.enable;
            }
        }
        catch (error) {
            if (this.mode === ValidatorMode.plugin) {
                mode = ValidatorMode.enable;
            }
            else {
                mode = this.mode;
            }
        }
        this.resolvedMode = mode;
        return mode;
    }
    async getSignature(userOp) {
        const mode = this.resolvedMode ??
            (await this.resolveValidatorMode(userOp.sender, userOp.callData));
        if (mode === ValidatorMode.sudo || mode === ValidatorMode.plugin) {
            return concatHex([this.mode, await this.signUserOp(userOp)]);
        }
        else {
            const enableData = await this.getEnableData(userOp.sender);
            const enableDataLength = enableData.length / 2 - 1;
            const enableSignature = this.getEnableSignature();
            if (!enableSignature) {
                throw new Error("Enable signature not set");
            }
            return concat([
                mode,
                pad(toHex(this.validUntil), { size: 6 }),
                pad(toHex(this.validAfter), { size: 6 }),
                pad(this.validatorAddress, { size: 20 }),
                pad(this.executor, { size: 20 }),
                pad(toHex(enableDataLength), { size: 32 }),
                enableData,
                pad(toHex(enableSignature.length / 2 - 1), { size: 32 }),
                enableSignature,
                await this.signUserOp(userOp),
            ]);
        }
    }
}
//# sourceMappingURL=base.js.map