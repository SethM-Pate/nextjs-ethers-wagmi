{"version":3,"file":"session-key-validator.js","sourceRoot":"","sources":["../../../../src/kernel-zerodev/validator/session-key-validator.ts"],"names":[],"mappings":";;;AAAA,8CAQ0B;AAC1B,uCAKmB;AACnB,+BAcc;AACd,sCAA2C;AAC3C,iFAA2E;AAC3E,kDAAkD;AAClD,qEAA+D;AAC/D,+CAA0C;AAC1C,8CAA6C;AAC7C,0CAAsD;AAOtD,gDAA2C;AAK1C,MAAM,CAAC,SAAiB,CAAC,MAAM,GAAG;IACjC,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;AACzB,CAAC,CAAC;AAiBF,IAAY,aAOX;AAPD,WAAY,aAAa;IACvB,mDAAS,CAAA;IACT,iEAAgB,CAAA;IAChB,2DAAa,CAAA;IACb,mFAAyB,CAAA;IACzB,6EAAsB,CAAA;IACtB,2DAAa,CAAA;AACf,CAAC,EAPW,aAAa,6BAAb,aAAa,QAOxB;AAmCD,SAAgB,UAAU,CAGxB,EACA,GAAG,EACH,IAAI,GAAG,EAAE,EACT,IAAI,GACkC;IAItC,MAAM,QAAQ,GAAI,GAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;IAC5E,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,SAAgB,CAAC;IACnD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,QAAQ,CAAC,CAAC,CAAQ,CAAC;IACrD,MAAM,qBAAqB,GAAG,EAAE,CAAC;IACjC,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;QAC9B,IAAI,CAAC,CAAC,QAAQ,IAAI,OAAO,CAAC;YAAE,SAAS;QACrC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;YAC9B,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC;gBAAE,OAAO,OAAc,CAAC;YAC1E,SAAS;SACV;QACD,IAAI,CAAC,OAAO,CAAC,MAAM;YAAE,SAAS;QAC9B,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC;YAAE,SAAS;QAC1C,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM;YAAE,SAAS;QACpD,qBAAqB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KACrC;IACD,IAAI,qBAAqB,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,QAAQ,CAAC,CAAC,CAAQ,CAAC;SAC7D,IAAI,qBAAqB,CAAC,MAAM,KAAK,CAAC;QACzC,OAAO,qBAAqB,CAAC,CAAC,CAAQ,CAAC;;QAEvC,MAAM,KAAK,CACT,mFAAmF,qBAAqB;aACrG,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAA,qBAAa,EAAC,IAAI,CAAC,CAAC;aAClC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CACpC,CAAC;AACN,CAAC;AAnCD,gCAmCC;AAED,SAAgB,oBAAoB,CAGlC,EACA,GAAG,EACH,MAAM,EACN,IAAI,EACJ,YAAY,EACZ,UAAU,EACV,SAAS,GACiD;IAC1D,MAAM,OAAO,GAAG,UAAU,CAAC;QACzB,GAAG;QACH,IAAI;QACJ,IAAI,EAAE,YAAY;KACK,CAAC,CAAC;IAC3B,IAAI,OAAO,CAAC,IAAI,KAAK,UAAU,EAAE;QAC/B,MAAM,KAAK,CAAC,GAAG,YAAY,mBAAmB,CAAC,CAAC;KACjD;IACD,MAAM,gBAAgB,GAAG,IAAA,0BAAmB,EAAC,OAAO,CAAC,CAAC;IACtD,IAAI,UAAU,GAAiB,EAAE,CAAC;IAClC,IAAI,IAAI,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QAC/B,UAAU,GAAI,IAA4C;aACvD,GAAG,CACF,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CACT,GAAG,IAAI;YACL,KAAK,EAAE,IAAA,UAAG,EACR,IAAA,YAAK,EAAC,GAAG,CAAC,KAAK,CAAC;gBACd,CAAC,CAAC,GAAG,CAAC,KAAK;gBACX,CAAC,CAAC,IAAA,YAAK,EAAC,GAAG,CAAC,KAAoC,CAAC,EACnD,EAAE,IAAI,EAAE,EAAE,EAAE,CACb;YACD,MAAM,EAAE,CAAC,GAAG,EAAE;YACd,SAAS,EAAE,GAAG,CAAC,QAAQ;SACxB,CACJ;aACA,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAiB,CAAC;KAC3C;IACD,OAAO;QACL,GAAG,EAAE,gBAAgB;QACrB,KAAK,EAAE,UAAU;QACjB,MAAM;QACN,UAAU,EAAE,UAAU,IAAI,EAAE;QAC5B,SAAS,EAAE,SAAS,IAAI,uBAAS,CAAC,IAAI;KACvC,CAAC;AACJ,CAAC;AA7CD,oDA6CC;AAED,MAAa,mBAAoB,SAAQ,6BAAmB;IAK1D,YAAY,MAAiC;QAC3C,KAAK,CAAC,MAAM,CAAC,CAAC;QALN;;;;;WAA+B;QACzC;;;;;WAA+B;QAC/B;;;;;WAAuB;QAIrB,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;QACpC,IAAI,CAAC,cAAc,GAAG;YACpB,GAAG,MAAM,CAAC,cAAc;YACxB,UAAU,EAAE,MAAM,CAAC,cAAc,CAAC,UAAU,IAAI,CAAC;YACjD,UAAU,EAAE,MAAM,CAAC,cAAc,CAAC,UAAU,IAAI,CAAC;YACjD,SAAS,EAAE,MAAM,CAAC,cAAc,CAAC,SAAS,IAAI,kBAAW;SAC1D,CAAC;QACF,IAAI,CAAC,cAAc,CAAC,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,GAAG,CACpE,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;YAChB,GAAG,IAAI;YACP,UAAU,EAAE,IAAI,CAAC,UAAU,IAAI,EAAE;YACjC,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,IAAA,UAAG,EAAC,IAAI,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;YACvC,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,EAAE;YACvB,KAAK;YACL,aAAa,EAAE,IAAI,CAAC,aAAa,IAAI;gBACnC,UAAU,EAAE,CAAC;gBACb,QAAQ,EAAE,CAAC;gBACX,IAAI,EAAE,CAAC;aACR;YACD,SAAS,EAAE,IAAI,CAAC,SAAS,IAAI,uBAAS,CAAC,IAAI;SAC5C,CAAC,CACH,CAAC;QACF,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QACvC,IAAI,CAAC,QAAQ;YACX,MAAM,CAAC,QAAQ;gBACf,IAAA,0BAAmB,EAAC,yCAAyC,CAAC,CAAC;QACjE,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,IAAI,kBAAW,CAAC;QAC/C,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,uBAAa,CAAC,MAAM,CAAC;IAClD,CAAC;IAEM,MAAM,CAAC,KAAK,CAAC,IAAI,CACtB,MAAiC;QAEjC,MAAM,OAAO,GAAG,MAAM,IAAA,qBAAU,EAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACnD,IAAI,CAAC,OAAO,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACtC;QACD,MAAM,KAAK,GAAG,IAAA,mBAAQ,EAAC,OAAO,CAAC,CAAC;QAChC,MAAM,QAAQ,GAAG,IAAI,mBAAmB,CAAC,EAAE,GAAG,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;QAC/D,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,yBAAyB;QACvB,OAAO,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,KAAK,IAAA,UAAG,EAAC,MAAM,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC;IACpE,CAAC;IAED,uBAAuB,CACrB,QAAa;QAEb,IAAI;YACF,MAAM,EAAE,YAAY,EAAE,IAAI,EAAE,GAAG,IAAA,yBAAkB,EAAC;gBAChD,GAAG,EAAE,sCAAgB;gBACrB,IAAI,EAAE,QAAQ;aACf,CAAC,CAAC;YAEH,IAAI,YAAY,KAAK,SAAS,IAAI,YAAY,KAAK,cAAc;gBAC/D,OAAO,SAAS,CAAC;YACnB,IAAI,YAAY,KAAK,SAAS,EAAE;gBAC9B,MAAM,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;gBAC/B,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;aAC3D;iBAAM,IAAI,YAAY,KAAK,cAAc,EAAE;gBAC1C,IAAI,OAAO,GAAU,EAAE,EACrB,MAAM,GAAa,EAAE,EACrB,SAAS,GAAU,EAAE,CAAC;gBACxB,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;oBACtB,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;oBACrB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBACvB,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAC3B,CAAC,CAAC,CAAC;gBACH,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;aAC3D;iBAAM;gBACL,MAAM,KAAK,CAAC,kBAAkB,CAAC,CAAC;aACjC;SACF;QAAC,OAAO,KAAK,EAAE;YACd,OAAO,SAAS,CAAC;SAClB;IACH,CAAC;IAEO,iBAAiB,CACvB,OAAkB,EAClB,SAAgB,EAChB,MAAgB;QAEhB,IACE,OAAO,CAAC,MAAM,KAAK,SAAS,CAAC,MAAM;YACnC,OAAO,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAChC;YACA,MAAM,KAAK,CAAC,mBAAmB,CAAC,CAAC;SAClC;QACD,MAAM,mBAAmB,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACxD,MAAM,eAAe,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC;YACxD,IAAI,CAAC,eAAe,IAAI,CAAC,eAAe,CAAC,MAAM;gBAAE,OAAO,SAAS,CAAC;YAElE,MAAM,aAAa,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;YAG3C,IAAI,iBAAiB,GAAG,eAAe,CAAC,MAAM,CAC5C,CAAC,UAAU,EAAE,EAAE,CACb,UAAU,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,aAAa;gBACjD,UAAU,CAAC,MAAM,CAAC,WAAW,EAAE,KAAK,kBAAW,CAAC,WAAW,EAAE,CAChE,CAAC;YAEF,IAAI,CAAC,iBAAiB,CAAC,MAAM;gBAAE,OAAO,SAAS,CAAC;YAEhD,MAAM,oBAAoB,GAAG,IAAI,CAAC,iBAAiB,CACjD,iBAAiB,EAEjB,uBAAS,CAAC,IAAI,CACf,CAAC;YAEF,IAAI,CAAC,oBAAoB,CAAC,MAAM;gBAAE,OAAO,SAAS,CAAC;YAEnD,MAAM,oBAAoB,GAAG,IAAI,CAAC,iBAAiB,CACjD,iBAAiB,EACjB,SAAS,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE,CAC5C,CAAC;YAEF,MAAM,qBAAqB,GAAG,oBAAoB,CAAC,MAAM,CACvD,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC,UAAU,CAAC,UAAU,IAAI,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAC/D,CAAC;YAEF,IAAI,CAAC,qBAAqB,CAAC,MAAM;gBAAE,OAAO,SAAS,CAAC;YAEpD,MAAM,iBAAiB,GAAG,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC5D,IAAI,CAAC,CAAC,CAAC,UAAU,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,UAAU,IAAI,EAAE,CAAC,EAAE;oBAC/C,OAAO,CAAC,CAAC;iBACV;qBAAM,IAAI,CAAC,CAAC,CAAC,UAAU,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,UAAU,IAAI,EAAE,CAAC,EAAE;oBACtD,OAAO,CAAC,CAAC,CAAC;iBACX;qBAAM;oBACL,OAAO,CAAC,CAAC;iBACV;YACH,CAAC,CAAC,CAAC;YAEH,OAAO,IAAI,CAAC,oBAAoB,CAAC,iBAAiB,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;QACxE,CAAC,CAAC,CAAC;QACH,OAAO,mBAAmB,CAAC,KAAK,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,KAAK,SAAS,CAAC;YACxE,CAAC,CAAE,mBAAoC;YACvC,CAAC,CAAC,SAAS,CAAC;IAChB,CAAC;IAEO,iBAAiB,CACvB,WAAyB,EACzB,SAAoB;QAEpB,OAAO,WAAW,CAAC,MAAM,CACvB,CAAC,UAAU,EAAE,EAAE,CACb,UAAU,CAAC,SAAS,KAAK,SAAS,IAAI,uBAAS,CAAC,IAAI,KAAK,SAAS,CACrE,CAAC;IACJ,CAAC;IAEO,iBAAiB,CACvB,WAAyB,EACzB,SAAiB;QAEjB,OAAO,WAAW,CAAC,MAAM,CACvB,CAAC,UAAU,EAAE,EAAE,CACb,CAAC,UAAU,CAAC,GAAG,IAAI,IAAA,UAAG,EAAC,IAAI,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,KAAK,SAAS,CACzE,CAAC;IACJ,CAAC;IAEO,oBAAoB,CAC1B,WAAyB,EACzB,IAAY;QAEZ,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE;YACrC,KAAK,MAAM,IAAI,IAAI,UAAU,CAAC,KAAK,IAAI,EAAE,EAAE;gBACzC,MAAM,SAAS,GAAQ,IAAI,CAAC,eAAe,CACzC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,CAAC,CACnE,CAAC;gBACF,MAAM,SAAS,GAAQ,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAExD,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE;oBACrE,OAAO,KAAK,CAAC;iBACd;aACF;YACD,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,eAAe,CAAC,KAAa;QACnC,OAAO,IAAA,UAAG,EAAC,IAAA,YAAK,EAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAA,YAAK,EAAC,KAAK,CAAC,EAAE;YAC9C,IAAI,EAAE,EAAE;SACT,CAAC,CAAC,WAAW,EAAS,CAAC;IAC1B,CAAC;IAEO,qBAAqB,CAC3B,SAAc,EACd,SAAc,EACd,SAAwB;QAExB,QAAQ,SAAS,EAAE;YACjB,KAAK,aAAa,CAAC,KAAK;gBACtB,OAAO,SAAS,KAAK,SAAS,CAAC;YACjC,KAAK,aAAa,CAAC,YAAY;gBAC7B,OAAO,SAAS,GAAG,SAAS,CAAC;YAC/B,KAAK,aAAa,CAAC,SAAS;gBAC1B,OAAO,SAAS,GAAG,SAAS,CAAC;YAC/B,KAAK,aAAa,CAAC,qBAAqB;gBACtC,OAAO,SAAS,IAAI,SAAS,CAAC;YAChC,KAAK,aAAa,CAAC,kBAAkB;gBACnC,OAAO,SAAS,IAAI,SAAS,CAAC;YAChC,KAAK,aAAa,CAAC,SAAS;gBAC1B,OAAO,SAAS,KAAK,SAAS,CAAC;YACjC;gBACE,OAAO,KAAK,CAAC;SAChB;IACH,CAAC;IAED,aAAa;QACX,MAAM,gBAAgB,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,GAAG,CAC3D,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,CAAC,CACtD,CAAC;QAIF,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC;YACnD,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC;QAE7C,OAAO,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC;YACtD,CAAC,CAAC,IAAI,yBAAU,CAAC,gBAAgB,EAAE,gBAAS,EAAE;gBAC1C,UAAU,EAAE,IAAI;gBAChB,SAAS,EAAE,IAAI;aAChB,CAAC;YACJ,CAAC,CAAC,IAAI,yBAAU,CAAC,CAAC,IAAA,UAAG,EAAC,MAAM,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,gBAAS,EAAE;gBACrD,UAAU,EAAE,KAAK;gBACjB,QAAQ,EAAE,IAAI;aACf,CAAC,CAAC;IACT,CAAC;IAED,oBAAoB,CAClB,UAAqC,EACrC,WAAmC;QAEnC,IAAI,eAAe,GAAG;YACpB,UAAU,EAAE;gBACV;oBACE,IAAI,EAAE,OAAO;oBACb,IAAI,EAAE,QAAQ;iBACf;gBACD;oBACE,IAAI,EAAE,QAAQ;oBACd,IAAI,EAAE,SAAS;iBAChB;gBACD;oBACE,IAAI,EAAE,KAAK;oBACX,IAAI,EAAE,QAAQ;iBACf;gBACD;oBACE,IAAI,EAAE,YAAY;oBAClB,IAAI,EAAE,SAAS;iBAChB;gBACD;oBACE,UAAU,EAAE;wBACV;4BACE,IAAI,EAAE,QAAQ;4BACd,IAAI,EAAE,SAAS;yBAChB;wBACD;4BACE,YAAY,EAAE,qBAAqB;4BACnC,IAAI,EAAE,WAAW;4BACjB,IAAI,EAAE,OAAO;yBACd;wBACD;4BACE,IAAI,EAAE,OAAO;4BACb,IAAI,EAAE,SAAS;yBAChB;qBACF;oBACD,IAAI,EAAE,OAAO;oBACb,IAAI,EAAE,SAAS;iBAChB;gBACD;oBACE,UAAU,EAAE;wBACV;4BACE,IAAI,EAAE,UAAU;4BAChB,IAAI,EAAE,QAAQ;yBACf;wBACD;4BACE,IAAI,EAAE,MAAM;4BACZ,IAAI,EAAE,QAAQ;yBACf;wBACD;4BACE,YAAY,EAAE,YAAY;4BAC1B,IAAI,EAAE,YAAY;4BAClB,IAAI,EAAE,QAAQ;yBACf;qBACF;oBACD,IAAI,EAAE,eAAe;oBACrB,IAAI,EAAE,OAAO;iBACd;gBACD;oBACE,YAAY,EAAE,gBAAgB;oBAC9B,IAAI,EAAE,WAAW;oBACjB,IAAI,EAAE,OAAO;iBACd;aACF;YACD,IAAI,EAAE,YAAY;YAClB,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO;SACtD,CAAC;QACF,IAAI,MAAM,CAAC;QACX,IAAI,MAAM,CAAC;QACX,IAAI,WAAW,EAAE;YACf,MAAM,GAAG;gBACP,eAAe;gBACf;oBACE,IAAI,EAAE,aAAa;oBACnB,IAAI,EAAE,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,WAAW;iBAClE;aACF,CAAC;YACF,MAAM,GAAG,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;SACpC;aAAM;YACL,MAAM,GAAG,CAAC,eAAe,CAAC,CAAC;YAC3B,MAAM,GAAG,CAAC,UAAU,CAAC,CAAC;SACvB;QACD,OAAO,IAAA,0BAAmB,EAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC7C,CAAC;IAED,cAAc;QACZ,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YACpC,MAAM,KAAK,CAAC,4CAA4C,CAAC,CAAC;SAC3D;QACD,OAAO;YACL,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,cAAc,EAAE,IAAI,CAAC,cAAc;YACnC,eAAe,EAAE,IAAI,CAAC,eAAe;SACtC,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,MAAM;QACV,OAAO,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAChD,CAAC;IAED,KAAK,CAAC,gBAAgB,CACpB,oBAA6B;QAE7B,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACtB,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;SAClE;QACD,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC;YACjD,GAAG,EAAE,kDAAsB;YAC3B,OAAO,EAAE,IAAI,CAAC,gBAAgB;YAC9B,YAAY,EAAE,QAAQ;YACtB,IAAI,EAAE,CAAC,oBAAoB,CAAC;SAC7B,CAAC,CAAC;QACH,OAAO,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;IACzD,CAAC;IAED,KAAK,CAAC,aAAa,CACjB,oBAA8B,EAC9B,gBAAyB;QAEzB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACpB,MAAM,KAAK,CAAC,+CAA+C,CAAC,CAAC;SAC9D;QACD,IAAI,CAAC,oBAAoB,EAAE;YACzB,MAAM,KAAK,CAAC,0DAA0D,CAAC,CAAC;SACzE;QACD,MAAM,SAAS,GACb,gBAAgB;YAChB,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,CAAC,CAAC,SAAS,GAAG,EAAE,CAAC;QACrE,OAAO,IAAA,aAAM,EAAC;YACZ,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;YAClC,IAAA,UAAG,EAAC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAS,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;YACtD,IAAA,UAAG,EAAC,IAAA,YAAK,EAAC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;YACvD,IAAA,UAAG,EAAC,IAAA,YAAK,EAAC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;YACvD,IAAI,CAAC,cAAc,CAAC,SAAU;YAC9B,IAAA,UAAG,EAAC,IAAA,YAAK,EAAC,SAAS,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;SACpC,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,eAAe,CACnB,oBAA6B,EAC7B,QAAa;QAEb,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;YACtB,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;SAClE;QACD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC;YACtD,GAAG,EAAE,sCAAgB;YACrB,OAAO,EAAE,oBAAoB;YAC7B,YAAY,EAAE,cAAc;YAC5B,IAAI,EAAE,CAAC,QAAQ,CAAC;SACjB,CAAC,CAAC;QACH,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC;YACtD,GAAG,EAAE,kDAAsB;YAC3B,OAAO,EAAE,IAAI,CAAC,gBAAgB;YAC9B,YAAY,EAAE,aAAa;YAC3B,IAAI,EAAE,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,EAAE,oBAAoB,CAAC;SACjE,CAAC,CAAC;QACH,MAAM,aAAa,GAAG,IAAA,gBAAS,EAAC;YAC9B,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;YAClC,IAAA,UAAG,EAAC,UAAU,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;YAChC,IAAA,UAAG,EAAC,IAAA,YAAK,EAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;YACtC,IAAA,UAAG,EAAC,IAAA,YAAK,EAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;YACtC,UAAU,CAAC,CAAC,CAAC;YACb,IAAA,UAAG,EAAC,IAAA,YAAK,EAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;SACxC,CAAC,CAAC;QACH,OAAO,CACL,UAAU,CAAC,SAAS,CAAC,WAAW,EAAE;YAChC,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE;YACrC,aAAa,CAAC,WAAW,EAAE;gBACzB,CACE,MAAM,IAAI,CAAC,aAAa,CAAC,oBAAoB,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAC9D,CAAC,WAAW,EAAE,CAClB,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,uBAAuB,CAAC,QAAa;QACzC,OAAO,IAAA,gBAAS,EAAC;YACf,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;YAClC,8BAAe;YACf,IAAI,CAAC,6BAA6B,CAAC,QAAQ,CAAC;SAC7C,CAAC,CAAC;IACL,CAAC;IAEO,6BAA6B,CAAC,QAAa;QACjD,MAAM,kBAAkB,GAAG,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QAClE,IAAI,CAAC,kBAAkB,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE,EAAE;YAC5D,MAAM,KAAK,CACT,kEAAkE,CACnE,CAAC;SACH;QACD,MAAM,qBAAqB,GACzB,IAAI,CAAC,cAAc,CAAC,WAAW;YAC/B,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;YAC5C,kBAAkB;YAChB,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,CAAC;YAC/C,CAAC,CAAC,IAAI,CAAC;QACX,IAAI,WAAW,GAA0B,EAAE,CAAC;QAC5C,IAAI,KAAK,CAAC,OAAO,CAAC,kBAAkB,CAAC,EAAE;YACrC,IAAI,YAAY,GAAG,kBAAkB,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CACvD,IAAA,gBAAS,EAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC,CACjD,CAAC;YACF,WAAW,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CACtC,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,CAClC,CAAC;SACH;aAAM,IAAI,kBAAkB,EAAE;YAC7B,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CACvC,IAAA,gBAAS,EAAC,qBAAqB,CAAC,CACjC,CAAC;SACH;QACD,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW;YACpC,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC;YAC5C,kBAAkB;YAClB,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,EAAE,WAAW,CAAC;YAC5D,CAAC,CAAC,IAAI,CAAC;IACX,CAAC;IAED,YAAY,CAAC,oBAAyB;QACpC,OAAO,IAAA,yBAAkB,EAAC;YACxB,GAAG,EAAE,kDAAsB;YAC3B,YAAY,EAAE,QAAQ;YACtB,IAAI,EAAE,CAAC,oBAAoB,CAAC;SAC7B,CAAC,CAAC;IACL,CAAC;IAED,aAAa,CAAC,UAAe;QAC3B,OAAO,IAAA,yBAAkB,EAAC;YACxB,GAAG,EAAE,kDAAsB;YAC3B,YAAY,EAAE,SAAS;YACvB,IAAI,EAAE,CAAC,UAAU,CAAC;SACnB,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,WAAW,CAAC,OAA4B;QAC5C,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,MAA2B;QAC7C,OAAO,IAAA,wBAAa,EAAC,MAAM,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC;IACpE,CAAC;IAED,KAAK,CAAC,UAAU,CAAC,MAA4B;QAC3C,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;SAC5C;QACD,MAAM,IAAI,GAAG,IAAA,8BAAoB,EAC/B;YACE,GAAG,MAAM;YACT,SAAS,EAAE,IAAI;SAChB,EACD,IAAI,CAAC,iBAAiB,EACtB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CACtB,CAAC;QACF,MAAM,gBAAgB,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAA,cAAO,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAEzE,MAAM,SAAS,GAAG,IAAA,aAAM,EAAC;YACvB,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;YAClC,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,gBAAgB,CAAC;YACnD,IAAI,CAAC,6BAA6B,CAAC,MAAM,CAAC,QAAQ,CAAC;SACpD,CAAC,CAAC;QACH,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AAtfD,kDAsfC","sourcesContent":["import {\n  getUserOperationHash,\n  type Address,\n  type Hex,\n  type SmartAccountSigner,\n  type UserOperationRequest,\n  type SignTypedDataParams,\n  type Abi,\n} from \"@alchemy/aa-core\";\nimport {\n  KernelBaseValidator,\n  ValidatorMode,\n  type KernelBaseValidatorParams,\n  type ValidatorPluginData,\n} from \"./base.js\";\nimport {\n  encodeFunctionData,\n  toBytes,\n  concat,\n  pad,\n  toHex,\n  encodeAbiParameters,\n  concatHex,\n  zeroAddress,\n  decodeFunctionData,\n  isHex,\n  getFunctionSelector,\n  type GetAbiItemParameters,\n  keccak256,\n} from \"viem\";\nimport { formatAbiItem } from \"viem/utils\";\nimport { SessionKeyValidatorAbi } from \"../abis/SessionKeyValidatorAbi.js\";\nimport { DUMMY_ECDSA_SIG } from \"../constants.js\";\nimport { KernelAccountAbi } from \"../abis/KernelAccountAbi.js\";\nimport { MerkleTree } from \"merkletreejs\";\nimport { getChainId } from \"../api/index.js\";\nimport { fixSignedData, getChain } from \"../utils.js\";\nimport type { GetAbiItemReturnType } from \"viem/dist/types/utils/abi/getAbiItem.js\";\nimport { type AbiFunction } from \"abitype\";\nimport type {\n  CombinedArgs,\n  GeneratePermissionFromArgsParameters,\n} from \"./types.js\";\nimport { Operation } from \"../provider.js\";\n\n// We need to be able to serialize bigint to transmit session key over\n// the network.\n// Using this trick: https://github.com/GoogleChromeLabs/jsbi/issues/30#issuecomment-1006086291\n(BigInt.prototype as any).toJSON = function () {\n  return this.toString();\n};\n\nexport interface SessionKeyValidatorParams extends KernelBaseValidatorParams {\n  sessionKey: SmartAccountSigner;\n  sessionKeyData: SessionKeyData;\n}\n\nexport type SessionKeyParams = Pick<\n  SessionKeyValidatorParams,\n  \"sessionKeyData\" | \"enableSignature\"\n> &\n  ValidatorPluginData & {\n    sessionPrivateKey?: Hex;\n    initCode?: Hex;\n    accountAddress?: Address;\n  };\n\nexport enum ParamOperator {\n  EQUAL = 0,\n  GREATER_THAN = 1,\n  LESS_THAN = 2,\n  GREATER_THAN_OR_EQUAL = 3,\n  LESS_THAN_OR_EQUAL = 4,\n  NOT_EQUAL = 5,\n}\n\nexport type SessionNonces = {\n  lastNonce: bigint;\n  invalidNonce: bigint;\n};\n\nexport type ExecutionRule = {\n  validAfter: number; // 48 bits\n  interval: number; // 48 bits\n  runs: number; // 48 bits\n};\nexport interface ParamRules {\n  offset: number;\n  condition: ParamOperator;\n  param: Hex;\n}\n\nexport type Permission = {\n  target: Address;\n  index?: number;\n  rules?: ParamRules[];\n  sig?: Hex;\n  valueLimit?: bigint;\n  executionRule?: ExecutionRule;\n  operation?: Operation;\n};\n\nexport interface SessionKeyData {\n  validUntil: number;\n  validAfter: number;\n  paymaster?: Address;\n  permissions?: Permission[];\n}\n\nexport function getAbiItem<\n  TAbi extends Abi | readonly unknown[],\n  TItemName extends string\n>({\n  abi,\n  args = [],\n  name,\n}: GetAbiItemParameters<TAbi, TItemName>): GetAbiItemReturnType<\n  TAbi,\n  TItemName\n> {\n  const abiItems = (abi as Abi).filter((x) => \"name\" in x && x.name === name);\n  if (abiItems.length === 0) return undefined as any;\n  if (abiItems.length === 1) return abiItems[0] as any;\n  const abiItemsParamFiltered = [];\n  for (const abiItem of abiItems) {\n    if (!(\"inputs\" in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem as any;\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    abiItemsParamFiltered.push(abiItem);\n  }\n  if (abiItemsParamFiltered.length === 0) return abiItems[0] as any;\n  else if (abiItemsParamFiltered.length === 1)\n    return abiItemsParamFiltered[0] as any;\n  else\n    throw Error(\n      `Couldn't parse funtion signature using params, set appropriate one from below:\\n${abiItemsParamFiltered\n        .map((item) => formatAbiItem(item))\n        .reduce((a, c) => `${a}\\n${c}`)}`\n    );\n}\n\nexport function getPermissionFromABI<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = string\n>({\n  abi,\n  target,\n  args,\n  functionName,\n  valueLimit,\n  operation,\n}: GeneratePermissionFromArgsParameters<TAbi, TFunctionName>): Permission {\n  const abiItem = getAbiItem({\n    abi,\n    args,\n    name: functionName,\n  } as GetAbiItemParameters);\n  if (abiItem.type !== \"function\") {\n    throw Error(`${functionName} not found in abi`);\n  }\n  const functionSelector = getFunctionSelector(abiItem);\n  let paramRules: ParamRules[] = [];\n  if (args && Array.isArray(args)) {\n    paramRules = (args as CombinedArgs<AbiFunction[\"inputs\"]>)\n      .map(\n        (arg, i) =>\n          arg && {\n            param: pad(\n              isHex(arg.value)\n                ? arg.value\n                : toHex(arg.value as Parameters<typeof toHex>[0]),\n              { size: 32 }\n            ),\n            offset: i * 32,\n            condition: arg.operator,\n          }\n      )\n      .filter((rule) => rule) as ParamRules[];\n  }\n  return {\n    sig: functionSelector,\n    rules: paramRules,\n    target,\n    valueLimit: valueLimit ?? 0n,\n    operation: operation ?? Operation.Call,\n  };\n}\n\nexport class SessionKeyValidator extends KernelBaseValidator {\n  protected sessionKey: SmartAccountSigner;\n  sessionKeyData: SessionKeyData;\n  merkleTree: MerkleTree;\n\n  constructor(params: SessionKeyValidatorParams) {\n    super(params);\n    this.sessionKey = params.sessionKey;\n    this.sessionKeyData = {\n      ...params.sessionKeyData,\n      validAfter: params.sessionKeyData.validAfter ?? 0,\n      validUntil: params.sessionKeyData.validUntil ?? 0,\n      paymaster: params.sessionKeyData.paymaster ?? zeroAddress,\n    };\n    this.sessionKeyData.permissions = this.sessionKeyData.permissions?.map(\n      (perm, index) => ({\n        ...perm,\n        valueLimit: perm.valueLimit ?? 0n,\n        sig: perm.sig ?? pad(\"0x\", { size: 4 }),\n        rules: perm.rules ?? [],\n        index,\n        executionRule: perm.executionRule ?? {\n          validAfter: 0,\n          interval: 0,\n          runs: 0,\n        },\n        operation: perm.operation ?? Operation.Call,\n      })\n    );\n    this.merkleTree = this.getMerkleTree();\n    this.selector =\n      params.selector ??\n      getFunctionSelector(\"execute(address, uint256, bytes, uint8)\");\n    this.executor = params.executor ?? zeroAddress;\n    this.mode = params.mode ?? ValidatorMode.plugin;\n  }\n\n  public static async init(\n    params: SessionKeyValidatorParams\n  ): Promise<SessionKeyValidator> {\n    const chainId = await getChainId(params.projectId);\n    if (!chainId) {\n      throw new Error(\"ChainId not found\");\n    }\n    const chain = getChain(chainId);\n    const instance = new SessionKeyValidator({ ...params, chain });\n    return instance;\n  }\n\n  shouldDelegateViaFallback(): boolean {\n    return this.merkleTree.getHexRoot() === pad(\"0x00\", { size: 32 });\n  }\n\n  findMatchingPermissions(\n    callData: Hex\n  ): Permission | Permission[] | undefined {\n    try {\n      const { functionName, args } = decodeFunctionData({\n        abi: KernelAccountAbi,\n        data: callData,\n      });\n\n      if (functionName !== \"execute\" && functionName !== \"executeBatch\")\n        return undefined;\n      if (functionName === \"execute\") {\n        const [to, value, data] = args;\n        return this.filterPermissions([to], [data], [value])?.[0];\n      } else if (functionName === \"executeBatch\") {\n        let targets: Hex[] = [],\n          values: bigint[] = [],\n          dataArray: Hex[] = [];\n        args[0].forEach((arg) => {\n          targets.push(arg.to);\n          values.push(arg.value);\n          dataArray.push(arg.data);\n        });\n        return this.filterPermissions(targets, dataArray, values);\n      } else {\n        throw Error(\"Invalid function\");\n      }\n    } catch (error) {\n      return undefined;\n    }\n  }\n\n  private filterPermissions(\n    targets: Address[],\n    dataArray: Hex[],\n    values: bigint[]\n  ): Permission[] | undefined {\n    if (\n      targets.length !== dataArray.length ||\n      targets.length !== values.length\n    ) {\n      throw Error(\"Invalid arguments\");\n    }\n    const filteredPermissions = targets.map((target, index) => {\n      const permissionsList = this.sessionKeyData.permissions;\n      if (!permissionsList || !permissionsList.length) return undefined;\n\n      const targetToMatch = target.toLowerCase();\n\n      // Filter permissions by target\n      let targetPermissions = permissionsList.filter(\n        (permission) =>\n          permission.target.toLowerCase() === targetToMatch ||\n          permission.target.toLowerCase() === zeroAddress.toLowerCase()\n      );\n\n      if (!targetPermissions.length) return undefined;\n\n      const operationPermissions = this.filterByOperation(\n        targetPermissions,\n        // [TODO]: Check if we need to pass operation from userOp after Kernel v2.3 in\n        Operation.Call\n      );\n\n      if (!operationPermissions.length) return undefined;\n\n      const signaturePermissions = this.filterBySignature(\n        targetPermissions,\n        dataArray[index].slice(0, 10).toLowerCase()\n      );\n\n      const valueLimitPermissions = signaturePermissions.filter(\n        (permission) => (permission.valueLimit ?? 0n) >= values[index]\n      );\n\n      if (!valueLimitPermissions.length) return undefined;\n\n      const sortedPermissions = valueLimitPermissions.sort((a, b) => {\n        if ((b.valueLimit ?? 0n) > (a.valueLimit ?? 0n)) {\n          return 1;\n        } else if ((b.valueLimit ?? 0n) < (a.valueLimit ?? 0n)) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n\n      return this.findPermissionByRule(sortedPermissions, dataArray[index]);\n    });\n    return filteredPermissions.every((permission) => permission !== undefined)\n      ? (filteredPermissions as Permission[])\n      : undefined;\n  }\n\n  private filterByOperation(\n    permissions: Permission[],\n    operation: Operation\n  ): Permission[] {\n    return permissions.filter(\n      (permission) =>\n        permission.operation === operation || Operation.Call === operation\n    );\n  }\n\n  private filterBySignature(\n    permissions: Permission[],\n    signature: string\n  ): Permission[] {\n    return permissions.filter(\n      (permission) =>\n        (permission.sig ?? pad(\"0x\", { size: 4 })).toLowerCase() === signature\n    );\n  }\n\n  private findPermissionByRule(\n    permissions: Permission[],\n    data: string\n  ): Permission | undefined {\n    return permissions.find((permission) => {\n      for (const rule of permission.rules ?? []) {\n        const dataParam: Hex = this.getFormattedHex(\n          \"0x\" + data.slice(10 + rule.offset * 2, 10 + rule.offset * 2 + 64)\n        );\n        const ruleParam: Hex = this.getFormattedHex(rule.param);\n\n        if (!this.evaluateRuleCondition(dataParam, ruleParam, rule.condition)) {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  private getFormattedHex(value: string): Hex {\n    return pad(isHex(value) ? value : toHex(value), {\n      size: 32,\n    }).toLowerCase() as Hex;\n  }\n\n  private evaluateRuleCondition(\n    dataParam: Hex,\n    ruleParam: Hex,\n    condition: ParamOperator\n  ): boolean {\n    switch (condition) {\n      case ParamOperator.EQUAL:\n        return dataParam === ruleParam;\n      case ParamOperator.GREATER_THAN:\n        return dataParam > ruleParam;\n      case ParamOperator.LESS_THAN:\n        return dataParam < ruleParam;\n      case ParamOperator.GREATER_THAN_OR_EQUAL:\n        return dataParam >= ruleParam;\n      case ParamOperator.LESS_THAN_OR_EQUAL:\n        return dataParam <= ruleParam;\n      case ParamOperator.NOT_EQUAL:\n        return dataParam !== ruleParam;\n      default:\n        return false;\n    }\n  }\n\n  getMerkleTree(): MerkleTree {\n    const permissionPacked = this.sessionKeyData.permissions?.map(\n      (permission) => this.encodePermissionData(permission)\n    );\n\n    // Having one leaf returns empty array in getProof(). To hack it we push the leaf twice\n    // issue - https://github.com/merkletreejs/merkletreejs/issues/58\n    if (permissionPacked && permissionPacked.length === 1)\n      permissionPacked.push(permissionPacked[0]);\n\n    return permissionPacked && permissionPacked.length !== 0\n      ? new MerkleTree(permissionPacked, keccak256, {\n          hashLeaves: true,\n          sortPairs: true,\n        })\n      : new MerkleTree([pad(\"0x00\", { size: 32 })], keccak256, {\n          hashLeaves: false,\n          complete: true,\n        });\n  }\n\n  encodePermissionData(\n    permission: Permission | Permission[],\n    merkleProof?: string[] | string[][]\n  ): Hex {\n    let permissionParam = {\n      components: [\n        {\n          name: \"index\",\n          type: \"uint32\",\n        },\n        {\n          name: \"target\",\n          type: \"address\",\n        },\n        {\n          name: \"sig\",\n          type: \"bytes4\",\n        },\n        {\n          name: \"valueLimit\",\n          type: \"uint256\",\n        },\n        {\n          components: [\n            {\n              name: \"offset\",\n              type: \"uint256\",\n            },\n            {\n              internalType: \"enum ParamCondition\",\n              name: \"condition\",\n              type: \"uint8\",\n            },\n            {\n              name: \"param\",\n              type: \"bytes32\",\n            },\n          ],\n          name: \"rules\",\n          type: \"tuple[]\",\n        },\n        {\n          components: [\n            {\n              name: \"interval\",\n              type: \"uint48\",\n            },\n            {\n              name: \"runs\",\n              type: \"uint48\",\n            },\n            {\n              internalType: \"ValidAfter\",\n              name: \"validAfter\",\n              type: \"uint48\",\n            },\n          ],\n          name: \"executionRule\",\n          type: \"tuple\",\n        },\n        {\n          internalType: \"enum Operation\",\n          name: \"operation\",\n          type: \"uint8\",\n        },\n      ],\n      name: \"permission\",\n      type: Array.isArray(permission) ? \"tuple[]\" : \"tuple\",\n    };\n    let params;\n    let values;\n    if (merkleProof) {\n      params = [\n        permissionParam,\n        {\n          name: \"merkleProof\",\n          type: Array.isArray(merkleProof[0]) ? \"bytes32[][]\" : \"bytes32[]\",\n        },\n      ];\n      values = [permission, merkleProof];\n    } else {\n      params = [permissionParam];\n      values = [permission];\n    }\n    return encodeAbiParameters(params, values);\n  }\n\n  getSessionData(): SessionKeyParams {\n    if (!this.selector || !this.executor) {\n      throw Error(\"Plugin Validator data params uninitialised\");\n    }\n    return {\n      selector: this.selector,\n      executor: this.executor,\n      validUntil: this.validUntil,\n      validAfter: this.validAfter,\n      sessionKeyData: this.sessionKeyData,\n      enableSignature: this.enableSignature,\n    };\n  }\n\n  async signer(): Promise<SmartAccountSigner> {\n    return await Promise.resolve(this.sessionKey);\n  }\n\n  async getSessionNonces(\n    kernelAccountAddress: Address\n  ): Promise<SessionNonces> {\n    if (!this.publicClient) {\n      throw new Error(\"Validator uninitialized: PublicClient missing\");\n    }\n    const nonce = await this.publicClient.readContract({\n      abi: SessionKeyValidatorAbi,\n      address: this.validatorAddress,\n      functionName: \"nonces\",\n      args: [kernelAccountAddress],\n    });\n    return { lastNonce: nonce[0], invalidNonce: nonce[1] };\n  }\n\n  async getEnableData(\n    kernelAccountAddress?: Address,\n    enabledLastNonce?: bigint\n  ): Promise<Hex> {\n    if (!this.merkleTree) {\n      throw Error(\"SessionKeyValidator: MerkleTree not generated\");\n    }\n    if (!kernelAccountAddress) {\n      throw Error(\"SessionKeyValidator: Kernel account address not provided\");\n    }\n    const lastNonce =\n      enabledLastNonce ??\n      (await this.getSessionNonces(kernelAccountAddress)).lastNonce + 1n;\n    return concat([\n      await this.sessionKey.getAddress(),\n      pad(this.merkleTree.getHexRoot() as Hex, { size: 32 }),\n      pad(toHex(this.sessionKeyData.validAfter), { size: 6 }),\n      pad(toHex(this.sessionKeyData.validUntil), { size: 6 }),\n      this.sessionKeyData.paymaster!,\n      pad(toHex(lastNonce), { size: 32 }),\n    ]);\n  }\n\n  async isPluginEnabled(\n    kernelAccountAddress: Address,\n    selector: Hex\n  ): Promise<boolean> {\n    if (!this.publicClient) {\n      throw new Error(\"Validator uninitialized: PublicClient missing\");\n    }\n    const execDetail = await this.publicClient.readContract({\n      abi: KernelAccountAbi,\n      address: kernelAccountAddress,\n      functionName: \"getExecution\",\n      args: [selector],\n    });\n    const enableData = await this.publicClient.readContract({\n      abi: SessionKeyValidatorAbi,\n      address: this.validatorAddress,\n      functionName: \"sessionData\",\n      args: [await this.sessionKey.getAddress(), kernelAccountAddress],\n    });\n    const enableDataHex = concatHex([\n      await this.sessionKey.getAddress(),\n      pad(enableData[0], { size: 32 }),\n      pad(toHex(enableData[1]), { size: 6 }),\n      pad(toHex(enableData[2]), { size: 6 }),\n      enableData[3],\n      pad(toHex(enableData[4]), { size: 32 }),\n    ]);\n    return (\n      execDetail.validator.toLowerCase() ===\n        this.validatorAddress.toLowerCase() &&\n      enableDataHex.toLowerCase() ===\n        (\n          await this.getEnableData(kernelAccountAddress, enableData[4])\n        ).toLowerCase()\n    );\n  }\n\n  async getDummyUserOpSignature(callData: Hex): Promise<Hex> {\n    return concatHex([\n      await this.sessionKey.getAddress(),\n      DUMMY_ECDSA_SIG,\n      this.getEncodedPermissionProofData(callData),\n    ]);\n  }\n\n  private getEncodedPermissionProofData(callData: Hex): Hex {\n    const matchingPermission = this.findMatchingPermissions(callData);\n    if (!matchingPermission && !this.shouldDelegateViaFallback()) {\n      throw Error(\n        \"SessionKeyValidator: No matching permission found for the userOp\"\n      );\n    }\n    const encodedPermissionData =\n      this.sessionKeyData.permissions &&\n      this.sessionKeyData.permissions.length !== 0 &&\n      matchingPermission\n        ? this.encodePermissionData(matchingPermission)\n        : \"0x\";\n    let merkleProof: string[] | string[][] = [];\n    if (Array.isArray(matchingPermission)) {\n      let encodedPerms = matchingPermission.map((permission) =>\n        keccak256(this.encodePermissionData(permission))\n      );\n      merkleProof = encodedPerms.map((perm) =>\n        this.merkleTree.getHexProof(perm)\n      );\n    } else if (matchingPermission) {\n      merkleProof = this.merkleTree.getHexProof(\n        keccak256(encodedPermissionData)\n      );\n    }\n    return this.sessionKeyData.permissions &&\n      this.sessionKeyData.permissions.length !== 0 &&\n      matchingPermission\n      ? this.encodePermissionData(matchingPermission, merkleProof)\n      : \"0x\";\n  }\n\n  encodeEnable(sessionKeyEnableData: Hex): Hex {\n    return encodeFunctionData({\n      abi: SessionKeyValidatorAbi,\n      functionName: \"enable\",\n      args: [sessionKeyEnableData],\n    });\n  }\n\n  encodeDisable(sessionKey: Hex): Hex {\n    return encodeFunctionData({\n      abi: SessionKeyValidatorAbi,\n      functionName: \"disable\",\n      args: [sessionKey],\n    });\n  }\n\n  async signMessage(message: string | Uint8Array): Promise<Hex> {\n    return await this.sessionKey.signMessage(message);\n  }\n\n  async signTypedData(params: SignTypedDataParams): Promise<Hex> {\n    return fixSignedData(await this.sessionKey.signTypedData(params));\n  }\n\n  async signUserOp(userOp: UserOperationRequest): Promise<Hex> {\n    if (!this.chain) {\n      throw new Error(\"Validator uninitialized\");\n    }\n    const hash = getUserOperationHash(\n      {\n        ...userOp,\n        signature: \"0x\",\n      },\n      this.entryPointAddress,\n      BigInt(this.chain.id)\n    );\n    const formattedMessage = typeof hash === \"string\" ? toBytes(hash) : hash;\n\n    const signature = concat([\n      await this.sessionKey.getAddress(),\n      await this.sessionKey.signMessage(formattedMessage),\n      this.getEncodedPermissionProofData(userOp.callData),\n    ]);\n    return signature;\n  }\n}\n"]}