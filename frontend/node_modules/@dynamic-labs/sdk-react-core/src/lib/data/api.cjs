'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var utils = require('@dynamic-labs/utils');
var sdkApi$1 = require('@dynamic-labs/sdk-api');
var version = require('../../version.cjs');
var ApiEndpoint = require('../config/ApiEndpoint.cjs');
var logger = require('../shared/logger.cjs');
require('@dynamic-labs/iconic');
require('@dynamic-labs/wallet-connector-core');
require('react/jsx-runtime');
require('../context/ViewContext/ViewContext.cjs');
require('react');
require('@dynamic-labs/wallet-book');
require('../utils/constants/colors.cjs');
require('../utils/constants/values.cjs');
require('../shared/utils/classes/storage/localStorage.cjs');
require('viem');
require('../shared/consts/index.cjs');
var helpers = require('../context/DynamicContext/helpers/helpers.cjs');

const sdkApi = (jwt) => {
    const settings = {
        basePath: ApiEndpoint.getBaseUrl(),
        headers: {
            'Content-Type': 'application/json',
        },
    };
    if (jwt) {
        settings.headers.Authorization = `Bearer ${jwt}`;
    }
    settings.headers['x-dyn-version'] = `WalletKit/${version.VERSION}`;
    settings.headers['x-dyn-api-version'] = `API/${version.API_VERSION}`;
    return new sdkApi$1.SDKApi(new sdkApi$1.Configuration(settings));
};
const fetchNonce = (environmentId) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const res = yield sdkApi().getNonce({
            environmentId,
        });
        return res.nonce;
    }
    catch (e) {
        return undefined;
    }
});
const getEmailProvider = (_a) => _tslib.__awaiter(void 0, [_a], void 0, function* ({ email, environmentId, }) {
    try {
        const res = yield sdkApi().getEmailProvider({
            email,
            environmentId,
        });
        return res;
    }
    catch (e) {
        const data = yield e.json();
        logger.logger.error(data.error);
        throw new utils.EmailProviderError(data.code);
    }
});
const createEmailVerification = (_b) => _tslib.__awaiter(void 0, [_b], void 0, function* ({ email, environmentId, captchaToken, }) {
    try {
        const res = yield sdkApi().createEmailVerification({
            emailVerificationCreateRequest: {
                captchaToken,
                email,
            },
            environmentId,
        });
        return res;
    }
    catch (e) {
        const data = yield e.json();
        logger.logger.error(data.error);
        throw new utils.EmailVerificationError(data.code);
    }
});
const signInWithEmailVerification = (_c) => _tslib.__awaiter(void 0, [_c], void 0, function* ({ verificationToken, verificationUUID, environmentId, captchaToken, }) {
    try {
        const res = yield sdkApi().signInWithEmailVerification({
            emailVerificationVerifyRequest: {
                captchaToken,
                verificationToken,
                verificationUUID,
            },
            environmentId,
        });
        return res;
    }
    catch (e) {
        const data = yield e.json();
        logger.logger.error(data.error);
        if (data.error.code === 'missing_from_list') {
            throw new utils.NoAccessError({ email: data.payload.email });
        }
        if (data.code === 'email_associated_with_different_provider') {
            throw new utils.AccountExistsError(data.error, data.payload);
        }
        throw new utils.EmailVerificationError(data.code);
    }
});
const retryEmailVerification = (_d) => _tslib.__awaiter(void 0, [_d], void 0, function* ({ email, environmentId, verificationUUID, }) {
    try {
        const res = yield sdkApi().retryEmailVerification({
            emailVerificationRetryRequest: {
                email,
                verificationUUID,
            },
            environmentId,
        });
        return res;
    }
    catch (e) {
        const data = yield e.json();
        logger.logger.error(data.error);
        throw new utils.EmailVerificationError(data.code);
    }
});
const verifyEmail = (_e, userJwt_1) => _tslib.__awaiter(void 0, [_e, userJwt_1], void 0, function* ({ verificationToken, verificationUUID, environmentId, }, userJwt) {
    try {
        const res = yield sdkApi(userJwt).verifyEmailVerification({
            emailVerificationVerifyRequest: {
                verificationToken,
                verificationUUID,
            },
            environmentId,
        });
        return res;
    }
    catch (e) {
        const data = yield e.json();
        logger.logger.error(data.error);
        if (data.code === sdkApi$1.UnprocessableEntityErrorCode.UserHasAlreadyAccountWithEmail) {
            throw new utils.UserHasAccountWithEmailError(data.error);
        }
        throw new utils.EmailVerificationError(data.code);
    }
});
const revokeSession = (_f, userJwt_2) => _tslib.__awaiter(void 0, [_f, userJwt_2], void 0, function* ({ environmentId, sessionId, }, userJwt) {
    try {
        yield sdkApi(userJwt).revokeSession({
            environmentId,
        });
    }
    catch (error) {
        const body = yield error.json();
        logger.logger.error(Error(body.error.message));
    }
});
const linkWallet = (environmentId_1, _g, userJwt_3) => _tslib.__awaiter(void 0, [environmentId_1, _g, userJwt_3], void 0, function* (environmentId, { messageToSign, network, signedMessage, publicWalletAddress, chain, walletName, walletProvider, additionalWalletAddresses, }, userJwt) {
    const verifyRequest = sdkApi$1.VerifyRequestFromJSON({
        additionalWalletAddresses,
        chain,
        messageToSign,
        network,
        publicWalletAddress,
        signedMessage,
        walletName,
        walletProvider,
    });
    try {
        const { jwt } = yield sdkApi(userJwt).verifyLink({
            environmentId,
            verifyRequest,
        });
        return jwt;
    }
    catch (e) {
        logger.logger.error(e);
        const data = yield e.json();
        if (data.code === 'reassign_wallet_confirm' ||
            data.code === 'reassign_wallet_error') {
            throw new utils.WalletUsedError(data.code);
        }
        return undefined;
    }
});
const unlinkWallet = (_h, userJwt_4) => _tslib.__awaiter(void 0, [_h, userJwt_4], void 0, function* ({ environmentId, primaryWalletId, walletId, }, userJwt) {
    try {
        const { jwt } = yield sdkApi(userJwt).verifyUnlink({
            environmentId,
            verifyUnlinkRequest: {
                primaryWalletId,
                walletId,
            },
        });
        return jwt;
    }
    catch (e) {
        return undefined;
    }
});
const transferWallet = (environmentId_2, _j, userJwt_5) => _tslib.__awaiter(void 0, [environmentId_2, _j, userJwt_5], void 0, function* (environmentId, { network, messageToSign, signedMessage, publicWalletAddress, chain, walletName, walletProvider, skipEmptyAccountCheck = false, }, userJwt) {
    // We should find a better way to do this than force type casting
    const verifyRequest = {
        chain,
        messageToSign,
        network,
        publicWalletAddress,
        signedMessage,
        skipEmptyAccountCheck,
        walletName,
        walletProvider,
    };
    try {
        const { jwt } = yield sdkApi(userJwt).verifyTransfer({
            environmentId,
            verifyRequest,
        });
        return jwt;
    }
    catch (_k) {
        return undefined;
    }
});
const mapChainToChainEnum = (chain) => {
    const foundChain = Object.values(sdkApi$1.ChainEnum).find((value) => value === chain);
    if (!foundChain) {
        throw new utils.DynamicError(`Invalid chain ${chain}`);
    }
    return foundChain;
};
const mapProviderToProviderEnum = (provider) => {
    const foundProvider = Object.values(sdkApi$1.WalletProviderEnum).find((value) => value === provider);
    if (!foundProvider) {
        throw new utils.DynamicError(`Invalid provider ${provider}`);
    }
    return foundProvider;
};
const mapAuthModeTypeToEnum = (authMode) => {
    const found = Object.values(sdkApi$1.AuthModeEnum).find((value) => value === authMode);
    if (!found) {
        throw new utils.DynamicError(`Invalid authMode ${authMode}`);
    }
    return found;
};
const createVisit = (_l) => _tslib.__awaiter(void 0, [_l], void 0, function* ({ authMode, chain, environmentId, walletProvider, publicWalletAddress, walletName, }) {
    try {
        const connectRequest = {
            address: publicWalletAddress,
            authMode: mapAuthModeTypeToEnum(authMode),
            chain: mapChainToChainEnum(chain),
            provider: mapProviderToProviderEnum(walletProvider),
            walletName,
        };
        yield sdkApi().createVisit({
            connectRequest,
            environmentId,
        });
    }
    catch (error) {
        // log error to console, don't do anything else
        logger.logger.error(error);
    }
});
const verifyWallet = (environmentId_3, _m) => _tslib.__awaiter(void 0, [environmentId_3, _m], void 0, function* (environmentId, { messageToSign, signedMessage, publicWalletAddress, chain, walletName, walletProvider, captchaToken, network, oauth, additionalWalletAddresses, }) {
    const verifyRequest = sdkApi$1.VerifyRequestFromJSON({
        additionalWalletAddresses,
        captchaToken,
        chain,
        messageToSign,
        network,
        oauth,
        publicWalletAddress,
        signedMessage,
        walletName,
        walletProvider,
    });
    try {
        const { jwt } = yield sdkApi().verify({
            environmentId,
            verifyRequest,
        });
        return jwt;
    }
    catch (e) {
        logger.logger.error(e);
        const data = yield e.json();
        if (data.code === 'wallet_not_deployed') {
            throw new utils.WalletNotDeployedError();
        }
        if (data.error.code === 'chainalysis_blocked_wallet') {
            throw new utils.ChainalysisError(data.payload.walletPublicKey);
        }
        if (data.error.code === 'gate_blocked') {
            throw new utils.GateBlockedError(data.payload.walletPublicKey);
        }
        if (data.error.code === 'missing_from_list') {
            throw new utils.NoAccessError({
                walletPublicKey: data.payload.walletPublicKey,
            });
        }
        if (data.code === 'email_associated_with_different_provider') {
            throw new utils.AccountExistsError(data.error, data.payload);
        }
        return undefined;
    }
});
const fetchProjectSettings = (environmentId) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const res = yield sdkApi().getEnvironmentSettings({
            environmentId,
        });
        return res;
    }
    catch (e) {
        logger.logger.error(e);
        return undefined;
    }
});
const updateUserProfileFields = (jwt, environmentId, fields) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    try {
        if (!jwt)
            throw new utils.DynamicError('User not authenticated');
        const res = yield sdkApi(jwt).updateSelf({
            environmentId,
            userFields: fields,
        });
        return res;
    }
    catch (e) {
        logger.logger.error(e);
        if (e instanceof Response) {
            const error = yield e.json();
            if (error.code === 'email_already_exists') {
                throw new utils.EmailAlreadyExistsError();
            }
            else if (error.code === 'username_already_exists') {
                throw new utils.UsernameAlreadyExistsError();
            }
            else if (error.code === 'too_many_verification_attempts') {
                throw new utils.TooManyEmailVerificationsError();
            }
        }
        throw e;
    }
});
const verifyOAuth = (environmentId_4, providerType_1, _o, userJwt_6) => _tslib.__awaiter(void 0, [environmentId_4, providerType_1, _o, userJwt_6], void 0, function* (environmentId, providerType, { code, codeVerifier, state }, userJwt) {
    const oauthRequest = {
        code,
        codeVerifier,
        state,
    };
    try {
        const { jwt } = yield sdkApi(userJwt).oauthVerify({
            environmentId,
            oauthRequest,
            providerType,
        });
        return jwt;
    }
    catch (e) {
        logger.logger.error(e);
        const data = yield e.json();
        if (data.code === 'social_account_already_exists') {
            throw new utils.SocialAccountAlreadyExistsError();
        }
        return undefined;
    }
});
const unlinkOAuth = (_p, userJwt_7) => _tslib.__awaiter(void 0, [_p, userJwt_7], void 0, function* ({ environmentId, primaryWalletId, verifiedCrentialId, }, userJwt) {
    try {
        const { jwt } = yield sdkApi(userJwt).verifyUnlink({
            environmentId,
            verifyUnlinkRequest: {
                primaryWalletId,
                verifiedCrentialId,
            },
        });
        return jwt;
    }
    catch (e) {
        return undefined;
    }
});
const signInOAuth = (environmentId_5, providerType_2, _q) => _tslib.__awaiter(void 0, [environmentId_5, providerType_2, _q], void 0, function* (environmentId, providerType, { code, codeVerifier, state, captchaToken }) {
    var _r;
    const oauthRequest = {
        captchaToken,
        code,
        codeVerifier,
        state,
    };
    try {
        const { jwt } = yield sdkApi().oauthSignIn({
            environmentId,
            oauthRequest,
            providerType,
        });
        return jwt;
    }
    catch (e) {
        logger.logger.error(e);
        const data = yield e.json();
        if (data.error.code === 'gate_blocked') {
            throw new utils.GateBlockedError(data.payload.walletPublicKey);
        }
        if (data.error.code === 'missing_from_list') {
            throw new utils.NoAccessError({
                walletPublicKey: (_r = data === null || data === void 0 ? void 0 : data.payload) === null || _r === void 0 ? void 0 : _r.walletPublicKey,
            });
        }
        if (data.code === 'email_associated_with_different_provider') {
            throw new utils.AccountExistsError(data.error, data.payload);
        }
        return undefined;
    }
});
const getOAuthResult = (environmentId_6, providerType_3, _s) => _tslib.__awaiter(void 0, [environmentId_6, providerType_3, _s], void 0, function* (environmentId, providerType, { state }) {
    const oauthResultRequest = {
        state,
    };
    try {
        const result = yield sdkApi().oauthResult({
            environmentId,
            oauthResultRequest,
            providerType,
        });
        return result;
    }
    catch (e) {
        logger.logger.error(e);
        return undefined;
    }
});
const getOnrampProviders = (_t) => _tslib.__awaiter(void 0, [_t], void 0, function* ({ chain, environmentId, networkId, token, walletAddress, }) {
    const { onramps } = yield sdkApi().getSupportedOnramps({
        chain,
        environmentId,
        networkId: networkId ? String(networkId) : undefined,
        token,
        walletAddress,
    });
    if (!onramps || onramps.length === 0) {
        throw new Error('No onramps');
    }
    return onramps;
});
const sendDynamicProps = (environmentId, settingsToSend) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const { dynamicContextProps, dynamicWagmiSettings, frameworkSettings } = settingsToSend;
        if (dynamicContextProps) {
            yield sendDynamicContextSettings(environmentId, { dynamicContextProps, frameworkSettings }, helpers.isDynamicContextSessionSettingExpired, helpers.setDynamicContextSessionSettings);
        }
        if (dynamicWagmiSettings) {
            yield sendDynamicContextSettings(environmentId, { dynamicWagmiSettings }, helpers.isWagmiSessionSettingExpired, helpers.setWagmiSessionSettings);
        }
    }
    catch (error) {
        logger.logger.warn('Error caught when sending sdkSettings to api. Please notify Dynamic, and send the DynamicContextProvider settings you currently have configured', { error });
    }
});
const sendDynamicContextSettings = (environmentId, sdkSettingsRequest, isSdkSettingExpired, setSDKSessionSettings) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    // sent once. no need to send again
    if (!isSdkSettingExpired()) {
        return;
    }
    yield sdkApi().logDynamicSdkSettings({ environmentId, sdkSettingsRequest });
    setSDKSessionSettings();
});
const mergeUserAccounts = (userJwt, environmentId) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const { jwt } = yield sdkApi(userJwt).mergeUsers({
            environmentId,
        });
        return jwt;
    }
    catch (e) {
        logger.logger.error(e);
        throw e;
    }
});
const createTurnkeyEmbeddedWallet = (_u) => _tslib.__awaiter(void 0, [_u], void 0, function* ({ attestation, challenge, environmentId, userJwt, chains = [sdkApi$1.ChainEnum.Evm], }) {
    const embeddedWallets = [
        {
            chains,
            embeddedWalletProvider: sdkApi$1.EmbeddedWalletProviderEnum.Turnkeyhd,
            isAuthenticatorAttached: false,
        },
    ];
    if (attestation && challenge) {
        embeddedWallets[0] = Object.assign(Object.assign({}, embeddedWallets[0]), { embeddedWalletSpecificOpts: {
                attestation,
                challenge,
            }, isAuthenticatorAttached: true });
    }
    return sdkApi(userJwt).createEmbeddedWallets({
        createEmbeddedWalletsRequest: {
            embeddedWallets,
        },
        environmentId,
    });
});
const initEmbeddedWalletSession = (_v) => _tslib.__awaiter(void 0, [_v], void 0, function* ({ authenticatorType, walletId, publicKey, environmentId, userJwt, }) {
    if (authenticatorType === 'passkey') {
        return sdkApi(userJwt).initPasskeyRecovery({
            environmentId,
            initPasskeyRecoveryRequest: {
                turnkeyRecoveryTargetPublicKey: publicKey,
                walletId,
            },
        });
    }
    return sdkApi(userJwt).initEmailAuth({
        environmentId,
        initEmailAuthRequest: {
            turnkeyEmailAuthTargetPublicKey: publicKey,
            walletId,
        },
    });
});
const completePasskeyRecovery = (_w) => _tslib.__awaiter(void 0, [_w], void 0, function* ({ walletId, attestation, challenge, environmentId, userJwt, }) {
    return sdkApi(userJwt).completePasskeyRecovery({
        completePasskeyRecoveryRequest: {
            attestation,
            challenge,
            walletId,
        },
        environmentId,
    });
});
const getUserPasskeys = (_x) => _tslib.__awaiter(void 0, [_x], void 0, function* ({ userJwt, environmentId, }) {
    try {
        const data = yield sdkApi(userJwt).getUserPasskeys({
            environmentId,
        });
        return data;
    }
    catch (e) {
        logger.logger.error(e);
        return {
            count: 0,
            passkeys: [],
        };
    }
});
const updateUserPasskey = (_y) => _tslib.__awaiter(void 0, [_y], void 0, function* ({ userJwt, environmentId, id, alias, }) {
    try {
        const data = yield sdkApi(userJwt).updatePasskey({
            environmentId,
            updateUserPasskeyRequest: { alias, id },
        });
        return data;
    }
    catch (e) {
        logger.logger.error(e);
        return undefined;
    }
});
const exportEmbeddedWallet = (_z) => _tslib.__awaiter(void 0, [_z], void 0, function* ({ userJwt, environmentId, walletId, activityId, }) {
    try {
        const data = yield sdkApi(userJwt).embeddedWalletExport({
            activityId,
            environmentId,
            walletId,
        });
        return data;
    }
    catch (e) {
        logger.logger.error(e);
        return { exportBundle: '' };
    }
});
const farcasterSignIn = (environmentId, farcasterSignInRequest) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    try {
        const { jwt } = yield sdkApi().farcasterSignIn({
            environmentId,
            farcasterSignInRequest,
        });
        return jwt;
    }
    catch (e) {
        logger.logger.error(e);
        const data = yield e.json();
        if (data.error.code === 'gate_blocked') {
            throw new utils.GateBlockedError(data.payload.walletPublicKey);
        }
        if (data.error.code === 'missing_from_list') {
            throw new utils.NoAccessError({
                walletPublicKey: data.payload.walletPublicKey,
            });
        }
        return undefined;
    }
});

exports.completePasskeyRecovery = completePasskeyRecovery;
exports.createEmailVerification = createEmailVerification;
exports.createTurnkeyEmbeddedWallet = createTurnkeyEmbeddedWallet;
exports.createVisit = createVisit;
exports.exportEmbeddedWallet = exportEmbeddedWallet;
exports.farcasterSignIn = farcasterSignIn;
exports.fetchNonce = fetchNonce;
exports.fetchProjectSettings = fetchProjectSettings;
exports.getEmailProvider = getEmailProvider;
exports.getOAuthResult = getOAuthResult;
exports.getOnrampProviders = getOnrampProviders;
exports.getUserPasskeys = getUserPasskeys;
exports.initEmbeddedWalletSession = initEmbeddedWalletSession;
exports.linkWallet = linkWallet;
exports.mapAuthModeTypeToEnum = mapAuthModeTypeToEnum;
exports.mapChainToChainEnum = mapChainToChainEnum;
exports.mapProviderToProviderEnum = mapProviderToProviderEnum;
exports.mergeUserAccounts = mergeUserAccounts;
exports.retryEmailVerification = retryEmailVerification;
exports.revokeSession = revokeSession;
exports.sendDynamicProps = sendDynamicProps;
exports.signInOAuth = signInOAuth;
exports.signInWithEmailVerification = signInWithEmailVerification;
exports.transferWallet = transferWallet;
exports.unlinkOAuth = unlinkOAuth;
exports.unlinkWallet = unlinkWallet;
exports.updateUserPasskey = updateUserPasskey;
exports.updateUserProfileFields = updateUserProfileFields;
exports.verifyEmail = verifyEmail;
exports.verifyOAuth = verifyOAuth;
exports.verifyWallet = verifyWallet;
