'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var walletSdk = require('@coinbase/wallet-sdk');
var viem = require('viem');
var utils = require('@dynamic-labs/utils');
var constants = require('../../constants.cjs');

const jsonRpcUrl = `https://mainnet.infura.io/v3/${constants.INFURA_ID}`;
const chainId = 1;
// storing a reference to the coinbase sdk so that we can call getQrUrl on it when we need a fresh qr code
let coinbaseSdk;
// storing a reference to the coinbase provider because the provider methods work better when
// they are called on the same instance
let coinbaseProvider;
const getCoinbaseClient = ({ opts: { appLogoUrl, appName = '', evmNetworks = [] } = {}, }) => {
    var _a, _b;
    if (!coinbaseProvider) {
        coinbaseSdk = new walletSdk.CoinbaseWalletSDK({
            appLogoUrl,
            appName,
            enableMobileWalletLink: true,
            headlessMode: true,
            reloadOnDisconnect: false,
        });
        const network = evmNetworks === null || evmNetworks === void 0 ? void 0 : evmNetworks.find((network) => network.chainId === chainId);
        const rpcUrl = ((_a = network === null || network === void 0 ? void 0 : network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a[0]) ||
            ((_b = network === null || network === void 0 ? void 0 : network.rpcUrls) === null || _b === void 0 ? void 0 : _b[0]) ||
            jsonRpcUrl;
        coinbaseProvider = coinbaseSdk.makeWeb3Provider(rpcUrl, chainId);
    }
    return { provider: coinbaseProvider, sdk: coinbaseSdk };
};
const killCoinbaseSession = () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    yield (coinbaseProvider === null || coinbaseProvider === void 0 ? void 0 : coinbaseProvider.close());
});
const fetchPublicAddress = (coinbaseProviderOpts, opts) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { provider, sdk } = getCoinbaseClient({ opts: coinbaseProviderOpts });
    const qrUrl = sdk.getQrUrl();
    if (!qrUrl) {
        throw new utils.DynamicError('no qr url available');
    }
    (_a = opts === null || opts === void 0 ? void 0 : opts.onDisplayUri) === null || _a === void 0 ? void 0 : _a.call(opts, qrUrl);
    const [address] = yield provider.request({
        method: 'eth_requestAccounts',
    });
    return address;
});
const signMessage = (coinbaseProviderOpts, messageToSign) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    const { provider } = getCoinbaseClient({ opts: coinbaseProviderOpts });
    const [address] = yield provider.request({
        method: 'eth_requestAccounts',
    });
    try {
        return yield provider.request({
            method: 'personal_sign',
            params: [viem.toHex(viem.toBytes(messageToSign)), address.toLowerCase()],
        });
    }
    catch (err) {
        yield provider.close();
        return undefined;
    }
});

exports.fetchPublicAddress = fetchPublicAddress;
exports.getCoinbaseClient = getCoinbaseClient;
exports.killCoinbaseSession = killCoinbaseSession;
exports.signMessage = signMessage;
