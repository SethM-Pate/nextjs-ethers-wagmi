import { __awaiter } from '../../_virtual/_tslib.js';
import EthereumProvider from '@walletconnect/ethereum-provider';
import EventEmitter from 'eventemitter3';
import { createWalletClient, custom } from 'viem';
import { toAccount } from 'viem/accounts';
import { logger, performPlatformSpecificConnectionMethod, getDeepLink } from '@dynamic-labs/wallet-connector-core';
import { getWalletBookWallet } from '@dynamic-labs/wallet-book';
import { DynamicError, isMobile } from '@dynamic-labs/utils';
import { chainsMap } from '@dynamic-labs/viem-utils';
import { EthWalletConnector } from '../EthWalletConnector.js';
import { parseIntSafe } from '../utils/parseIntSafe.js';

const activeAccountKey = (walletName) => `dynamic-wc2-active-account-${walletName}`;
const sessionTopicKey = (walletName) => `dynamic-wc2-session-topic-${walletName}`;
const swicthedNetworkKey = (walletName) => `dynamic-wc2-switched-network-${walletName}`;
const currentChainKey = (walletName) => `dynamic-wc2-current-chain-${walletName}`;
const ee = new EventEmitter();
class WalletConnectV2 extends EthWalletConnector {
    constructor(opts) {
        var _a;
        super(opts);
        this.supportedChains = ['EVM', 'ETH'];
        this.connectedChain = 'EVM';
        this.isInitialized = false;
        this.canConnectViaQrCode = true;
        this.isWalletConnect = true;
        this.preferredChains = [];
        // When trying to switch network for MetaMask, the switch promise gets stuck
        // if the switch got trigged once already, so we need to keep track of that
        this._hasSwitchedNetwork = false;
        this.sessionEventHandler = () => { };
        this.sessionDeleteHandler = () => { };
        this.name = opts.walletName;
        this.projectId = opts.projectId;
        this.deepLinkPreference = opts.deepLinkPreference || 'native';
        this.preferredChains = opts.walletConnectPreferredChains || [];
        this.hasSwitchedNetwork =
            (_a = Boolean(localStorage.getItem(this.swicthedNetworkKey))) !== null && _a !== void 0 ? _a : false;
        const lsCurrentChain = localStorage.getItem(this.currentChainKey);
        this.currentChainId = lsCurrentChain
            ? parseIntSafe(lsCurrentChain)
            : undefined;
    }
    getMappedChains() {
        return (this.evmNetworks
            // Filters out palm that crashes Trust Wallet
            .filter((network) => network.chainId !== 11297108109)
            .map((network) => `eip155:${network.chainId}`));
    }
    getMappedChainsByPreferredOrder() {
        // adding Ethereum to avoid an error connecting if none of the evm networks are supported by the wallet
        const allChains = this.getMappedChains();
        if (!allChains.includes('eip155:1')) {
            allChains.push('eip155:1');
        }
        const reorderedChains = this.preferredChains.filter((chain) => allChains.includes(chain));
        const remainingChains = allChains.filter((chain) => !this.preferredChains.includes(chain));
        return [...reorderedChains, ...remainingChains].map((chain) => Number(chain.split(':')[1]));
    }
    initConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider } = WalletConnectV2;
            if (!provider) {
                throw new DynamicError('No provider found (init connection)');
            }
            // this means there is already a connection in progress, so don't call connect again
            if (provider === null || provider === void 0 ? void 0 : provider.signer.uri) {
                return;
            }
            provider.connect().catch((e) => {
                logger.error(e);
                ee.emit('walletconnect_connection_failed', e);
            });
        });
    }
    createProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            return EthereumProvider.init({
                events: ['chainChanged', 'accountsChanged'],
                methods: [],
                optionalChains: this.getMappedChainsByPreferredOrder(),
                optionalMethods: [
                    'eth_chainId',
                    'eth_signTypedData',
                    'eth_signTransaction',
                    'eth_sign',
                    'personal_sign',
                    'eth_sendTransaction',
                    'eth_signTypedData_v4',
                    'wallet_switchEthereumChain',
                    'wallet_addEthereumChain',
                ],
                projectId: this.projectId,
                rpcMap: this.evmNetworkRpcMap(),
                showQrModal: false,
            });
        });
    }
    getWalletClientFromInitializedProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            const walletConnect = this.createProvider();
            const walletClient = createWalletClient({
                account: this.activeAccount ? toAccount(this.activeAccount) : undefined,
                transport: custom(yield walletConnect),
            });
            return walletClient;
        });
    }
    createInitProviderPromise() {
        return __awaiter(this, void 0, void 0, function* () {
            WalletConnectV2.provider = yield this.createProvider();
            this.teardownEventListeners();
            this.setupEventListeners();
        });
    }
    initProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider } = WalletConnectV2;
            if (!provider) {
                if (this.initializePromise === undefined) {
                    this.initializePromise = this.createInitProviderPromise();
                }
                yield this.initializePromise;
            }
        });
    }
    refreshSession() {
        var _a, _b, _c, _d, _e;
        if ((_b = (_a = WalletConnectV2.provider) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.topic) {
            if (localStorage.getItem(this.sessionTopicKey) ===
                ((_d = (_c = WalletConnectV2.provider) === null || _c === void 0 ? void 0 : _c.session) === null || _d === void 0 ? void 0 : _d.topic)) {
                this.session = WalletConnectV2.provider.session;
                this.activeAccount = ((_e = localStorage.getItem(this.activeAccountKey)) !== null && _e !== void 0 ? _e : undefined);
            }
        }
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initProvider();
            yield this.initConnection();
            this.isInitialized = true;
        });
    }
    get sessionTopicKey() {
        return sessionTopicKey(this.key);
    }
    get activeAccountKey() {
        return activeAccountKey(this.key);
    }
    get swicthedNetworkKey() {
        return swicthedNetworkKey(this.key);
    }
    get currentChainKey() {
        return currentChainKey(this.key);
    }
    set currentChainId(value) {
        this._currentChainId = value;
        if (value) {
            localStorage.setItem(this.currentChainKey, value.toString());
        }
        else {
            localStorage.removeItem(this.currentChainKey);
        }
    }
    get currentChainId() {
        return this._currentChainId;
    }
    set hasSwitchedNetwork(value) {
        this._hasSwitchedNetwork = value;
        if (value) {
            localStorage.setItem(this.swicthedNetworkKey, value.toString());
        }
        else {
            localStorage.removeItem(this.swicthedNetworkKey);
        }
    }
    get hasSwitchedNetwork() {
        return this._hasSwitchedNetwork;
    }
    supportsNetworkSwitching() {
        return true;
    }
    setupEventListeners() {
        if (!WalletConnectV2.provider) {
            return;
        }
        this.sessionEventHandler = ({ params, }) => {
            logger.debug('session_event was called', { params });
            if (!params || !params.event) {
                logger.debug('session_event was called without params or params.event');
                return;
            }
            const { name, data } = params.event;
            if (name === 'chainChanged') {
                const chainId = parseIntSafe(data);
                if (chainId === this.currentChainId) {
                    logger.debug(`ignoring chainChanged event with same chain id as current chain id: ${chainId}`);
                    return;
                }
                if (chainId === undefined) {
                    logger.debug(`received unexpected data for chainChanged: ${data} with type ${typeof data}}`);
                    return;
                }
                this.currentChainId = chainId;
                this.emit('chainChange', { chain: String(chainId) });
                this.hasSwitchedNetwork = true;
                // When a user switches network from their wallet, we need the provider to change network
                // such that any future calls to `getNetwork` will return the correct network
                this.switchNetwork({ networkChainId: chainId });
            }
            else if (name === 'accountsChanged') {
                if (!Array.isArray(data)) {
                    logger.debug(`received unexpected data for accountsChanged: ${data} with type ${typeof data}}`);
                    return;
                }
                // eslint-disable-next-line prefer-destructuring
                const account = data[0].split(':')[2];
                this.setActiveAccount(account);
            }
        };
        WalletConnectV2.provider.on('session_event', this.sessionEventHandler);
        this.sessionDeleteHandler = () => __awaiter(this, void 0, void 0, function* () {
            this.endSession();
            this.emit('disconnect');
        });
        WalletConnectV2.provider.on('session_delete', this.sessionDeleteHandler);
    }
    teardownEventListeners() {
        if (!WalletConnectV2.provider) {
            return;
        }
        WalletConnectV2.provider.off('session_event', this.sessionEventHandler);
        WalletConnectV2.provider.off('session_delete', this.sessionDeleteHandler);
    }
    getWalletClient(chainId) {
        if (!WalletConnectV2.provider) {
            return;
        }
        return createWalletClient({
            account: this.activeAccount ? toAccount(this.activeAccount) : undefined,
            chain: chainsMap[chainId !== null && chainId !== void 0 ? chainId : String(this.currentChainId)],
            transport: custom(WalletConnectV2.provider),
        });
    }
    fetchPublicAddress(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this.activeAccount) {
                return this.activeAccount;
            }
            if (!WalletConnectV2.provider || !((_a = WalletConnectV2.provider) === null || _a === void 0 ? void 0 : _a.signer.uri)) {
                logger.debug('No WC2 provider found, re-initializing...');
                yield this.endSession();
                yield this.init();
                // sleep 1 s to wait for connect call to finish
                // the connect call isn't await-ed because it only resolves once
                // the connection is established, but we need to wait for it to
                // finish setting up the connection URI and making it available
                // on the provider
                yield new Promise((resolve) => setTimeout(resolve, 1000));
                if (!WalletConnectV2.provider || !((_b = WalletConnectV2.provider) === null || _b === void 0 ? void 0 : _b.signer.uri)) {
                    logger.debug('No WC2 provider found, escaping and throwing error');
                    throw new DynamicError('No provider found');
                }
            }
            const metadata = getWalletBookWallet(this.walletBook, this.key);
            performPlatformSpecificConnectionMethod(WalletConnectV2.provider.signer.uri, metadata, {
                onDesktopUri: opts === null || opts === void 0 ? void 0 : opts.onDesktopUri,
                onDisplayUri: opts === null || opts === void 0 ? void 0 : opts.onDisplayUri,
            }, this.deepLinkPreference);
            return new Promise((resolve, reject) => {
                if (!WalletConnectV2.provider) {
                    reject(new DynamicError('No provider found'));
                    return;
                }
                ee.on('walletconnect_connection_failed', () => {
                    const error = new DynamicError('Connection rejected. Please try again.');
                    error.code = 'connection_rejected';
                    if (WalletConnectV2.provider) {
                        WalletConnectV2.provider.signer.uri = undefined;
                        // this is needed for mobile to work when using universal links.
                        // if the user cancels the connection, we need to re-initialize the provider
                        // so that the async work is done ahead of time, before the user tries to connect again,
                        // otherwise they will trigger the iOS bug where they are redirected to the app store
                        this.init();
                    }
                    reject(error);
                });
                WalletConnectV2.provider.on('connect', () => {
                    var _a;
                    const session = (_a = WalletConnectV2.provider) === null || _a === void 0 ? void 0 : _a.session;
                    if (!session) {
                        reject(new DynamicError('No session found'));
                        return;
                    }
                    this.setSession(session);
                    this.setActiveAccount(session.namespaces.eip155.accounts[0].split(':')[2]);
                    this.getNetwork().then((chainId) => {
                        this.currentChainId = chainId;
                        resolve(this.activeAccount);
                    });
                });
            });
        });
    }
    /**
     * WalletConnect V2 will fail to send the sign message request if the chainId
     * is not the same as the one in the session. This method will wait for the
     * chainId to change and then retry the sign message request.
     *
     * Otherwise it will just return the result of the sign message request.
     *
     * @param signMessageFn - Function to sign message with provider
     * @param messageToSign - Message to sign
     * @returns
     */
    waitForSignMessage(signMessageFn, messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const raceConditionPromise = new Promise((resolve, reject) => {
                // Create listener for chain change event
                this.on('chainChange', () => resolve({ success: false }));
                signMessageFn(messageToSign)
                    .then((result) => resolve({ signedMessage: result, success: true }))
                    .catch(reject);
            });
            const signedMessageResult = yield raceConditionPromise;
            if (signedMessageResult.success === false) {
                return signMessageFn(messageToSign);
            }
            return signedMessageResult.signedMessage;
        });
    }
    getDeepLink() {
        var _a;
        if (!this.session) {
            return;
        }
        const metadata = getWalletBookWallet(this.walletBook, this.key);
        const deepLink = getDeepLink({
            metadata,
            mode: 'regular',
            preference: this.deepLinkPreference,
            uri: (_a = WalletConnectV2.provider) === null || _a === void 0 ? void 0 : _a.signer.uri,
        });
        if (!deepLink) {
            return;
        }
        // we need to include the session topic here because it helps the wallet
        // auto redirect back to the dapp after signing
        return `${deepLink}?sessionTopic=${this.session.topic}`;
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.session) {
                throw new DynamicError('no session');
            }
            const deepLink = this.getDeepLink();
            if (isMobile() && deepLink) {
                window.location.href = deepLink;
            }
            const signMessageFn = (messageToSign) => __awaiter(this, void 0, void 0, function* () {
                const { activeAccount } = this;
                if (!activeAccount) {
                    return;
                }
                const walletClient = yield this.getWalletClientFromInitializedProvider();
                return walletClient.signMessage({
                    account: activeAccount,
                    message: messageToSign,
                });
            });
            const response = yield this.waitForSignMessage(signMessageFn, messageToSign);
            return response;
        });
    }
    clearActiveAccount() {
        localStorage.removeItem(this.activeAccountKey);
        this.activeAccount = undefined;
    }
    clearSession() {
        localStorage.removeItem(this.sessionTopicKey);
        this.session = undefined;
    }
    setActiveAccount(account) {
        localStorage.setItem(this.activeAccountKey, account);
        this.activeAccount = account;
        this.emit('accountChange', { accounts: [account] });
    }
    setSession(session) {
        localStorage.setItem(this.sessionTopicKey, session.topic);
        this.session = session;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            this.clearActiveAccount();
            this.clearSession();
            this.hasSwitchedNetwork = false;
            this.currentChainId = undefined;
            if (!((_a = WalletConnectV2.provider) === null || _a === void 0 ? void 0 : _a.session)) {
                return;
            }
            try {
                yield WalletConnectV2.provider.disconnect();
                // We must unset provider on logout so that a new session can be established
                // If we don't then the provider will still have the old session and will hang
                WalletConnectV2.provider = undefined;
            }
            catch (e) {
                logger.debug(e);
            }
        });
    }
    getNetwork() {
        const _super = Object.create(null, {
            getNetwork: { get: () => super.getNetwork }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentChainId) {
                return this.currentChainId;
            }
            yield this.initProvider();
            return _super.getNetwork.call(this);
        });
    }
    providerSwitchNetwork(_a) {
        const _super = Object.create(null, {
            providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
        });
        return __awaiter(this, arguments, void 0, function* ({ network, }) {
            const supportedNetworks = yield this.getSupportedNetworks();
            if (!(supportedNetworks === null || supportedNetworks === void 0 ? void 0 : supportedNetworks.includes(network.chainId.toString()))) {
                const error = new DynamicError('Network switching is not available at this time. The user should manually switch network in their wallet');
                error.code = 'network_switching_only_available_in_wallet';
                throw error;
            }
            const currentNetworkId = yield this.getNetwork();
            if (currentNetworkId && currentNetworkId === network.chainId) {
                return;
            }
            if (this.switchNetworkOnlyFromWallet) {
                throw new DynamicError('Network switching is only supported through the wallet');
            }
            if (!this.supportsNetworkSwitching()) {
                throw new DynamicError('Network switching not supported');
            }
            const walletClient = yield this.getWalletClientFromInitializedProvider();
            if (this.isMetaMask()) {
                const deepLink = this.getDeepLink();
                if (deepLink) {
                    window.location.href = deepLink;
                }
            }
            yield _super.providerSwitchNetwork.call(this, { network, provider: walletClient });
            this.currentChainId = network.chainId;
            this.hasSwitchedNetwork = true;
            this.emit('chainChange', { chain: String(network.chainId) });
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isInitialized === false) {
                yield this.initProvider();
                this.refreshSession();
                this.isInitialized = true;
            }
            if (!this.activeAccount) {
                return [];
            }
            return [this.activeAccount];
        });
    }
    isMetaMask() {
        var _a, _b, _c, _d, _e;
        return ((_e = (_d = (_c = (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.peer) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c.name) === null || _d === void 0 ? void 0 : _d.toLowerCase().startsWith('metamask')) !== null && _e !== void 0 ? _e : false);
    }
    getSupportedNetworks() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            yield this.initProvider();
            this.refreshSession();
            if (this.isMetaMask()) {
                if (this.hasSwitchedNetwork) {
                    return [String(this.currentChainId)];
                }
                return this.evmNetworks.map((network) => network.chainId.toString());
            }
            if (!this.session) {
                return [];
            }
            const chains = [];
            // Some wallet (i.e ZenGo) use namespaces.account to list supported chains
            // while others use keys within the namespaces object
            Object.keys(this.session.namespaces).forEach((key) => {
                if (key.startsWith('eip155:')) {
                    chains.push(key.split(':')[1]);
                }
            });
            (_a = this.session.namespaces.eip155) === null || _a === void 0 ? void 0 : _a.accounts.forEach((account) => chains.push(account.split(':')[1]));
            return chains.length
                ? chains
                : this.evmNetworks.map((network) => network.chainId.toString());
        });
    }
}

export { WalletConnectV2 };
